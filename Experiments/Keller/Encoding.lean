/-
Copyright (c) 2024 The Trestle Contributors.
Released under the Apache License v2.0; see LICENSE for full text.

Authors: James Gallicchio
-/

import Trestle.Encode
import Trestle.Solver.Dimacs
import Trestle.Upstream.IndexTypeInstances

import Experiments.Keller.KellerGraph
import Experiments.Keller.SymmBreak.TwoCubes
import Experiments.Keller.SymmBreak.C3Zeros
import Experiments.Keller.SymmBreak.MatrixGen

namespace Keller.Encoding

open Trestle Encode

inductive Vars (n s : Nat)
-- coordinates of each of the 2^n clique nodes
| x (i : BitVec n) (j : Fin n) (k : Fin s)
deriving IndexType, Hashable, Ord

instance : ToString (Vars n s) where
  toString | Vars.x i j k => s!"x{i.toNat},{j},{k}"

inductive AllVars (n s : Nat)
| x (i : BitVec n) (j : Fin n) (k : Fin s)
| y (i i' : BitVec n) (j : Fin n) (k : Fin s)
| z (i i' : BitVec n) (j : Fin n)
deriving DecidableEq

instance : ToString (AllVars n s) where
  toString
    | .x i j k    => s!"x{i.toNat},{j},{k}"
    | .y i i' j k => s!"y{i.toNat},{i'.toNat},{j},{k}"
    | .z i i' j   => s!"z{i.toNat},{i'.toNat},{j}"

def allBitVecs (n) : Array (BitVec n) := Array.ofFn (BitVec.ofFin)

@[simp] theorem mem_allBitVecs (x : BitVec n) : x ∈ allBitVecs n := by
  simp [allBitVecs]



section Spec

open Vars

def baseSpec : Model.PropPred (Vars n s) :=
  (fun τ =>
    -- type 1 clauses in paper
    (∀ (i : BitVec n) (j : Fin n), ∃! k, τ (x i j k)) ∧
    -- type 2 clauses in paper
    (∀ (i i' : BitVec n) (j : Fin n), i ^^^ i' = BitVec.oneAt j →
        ∃ j', j' ≠ j ∧ ∃ k, τ (x i j' k) ≠ τ (x i' j' k)) ∧
    -- type 5/6 clauses in paper
    (∀ (i i' : BitVec n), i ≠ i' → ∃ j, i[j] ≠ i'[j] ∧ ∀ (k : Fin s), τ (x i j k) = τ (x i' j k)))

def c0_c1_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ =>
    (∀ j, τ (x 0 j SymmBreak.TwoCubes.c0_colors[j])) ∧
    (∀ j, τ (x 1 j SymmBreak.TwoCubes.c1_colors[j]))

def c3_sorted_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ => ∀ (j : Nat) (range : 2 ≤ j ∧ j + 1 < n+2),
    τ (x 3 ⟨j,by omega⟩ 0) → τ (x 3 ⟨j+1,by omega⟩ 0)

def c3_more_nonzero_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ =>
    ∀ (j : Nat) (range : 2 ≤ j ∧ j + 1 < n + 2)
      (col : Nat) (cr : 2 ≤ col ∧ col ≤ j),
      ¬ τ (x 3 ⟨j,by omega⟩ 0) ∧ τ (x 3 ⟨j+1,by omega⟩ 0) →
      (∀ (_j : Nat) (range : 2 ≤ _j ∧ _j ≤ j),
        ¬ τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))
      → (∀ (_j : Nat) (range : j < _j ∧ _j < n + 2),
        τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))


def fullSpec : Model.PropPred (Vars n s) :=
  fun τ =>
    baseSpec τ ∧
    (match n,s with
    | _+2, _+2 => c0_c1_spec τ ∧ c3_sorted_spec τ ∧ c3_more_nonzero_spec τ
    | _,_ => True)


def cliqueToAssn (c : KClique n s) : Model.PropAssignment (Vars n s) :=
  fun | .x i j k => (c.get i)[j] = k

def assnToVertices (τ : Model.PropAssignment (Vars n s)) : Set (KVertex n s) :=
  fun ⟨i,cs⟩ => ∀ j, τ (x i j (cs[j]))

open Model.PropPred in
/-- `baseSpec` is satisfied by the assignment generated by `c` -/
theorem cliqueToAssn_satisfies_baseSpec (c : KClique n s) :
    cliqueToAssn c ⊨ baseSpec := by
  unfold baseSpec cliqueToAssn
  refine ⟨?_,?_,?_⟩
  · -- this should just be simp but for some reason existsUnique_eq' is not applying
    intro i j; simp only [Model.PropFun.satisfies_var, decide_eq_true_eq]; apply existsUnique_eq' (a' := (c.get i)[j])
  · intro i i' j is_xor
    have ⟨_,j2,js_ne,h⟩ := c.get_adj_of_xor_eq j is_xor
    use j2, js_ne, (c.get i')[j2]
    simpa using h
  · intro i i' is_ne
    have ⟨j1,is_ne_j1,cs_eq_j1,_⟩ := c.get_adj is_ne
    use j1, is_ne_j1
    simpa using cs_eq_j1

open Model.PropPred in
/-- `fullSpec` is satisfied by a `C3Zeros` instance -/
theorem cliqueToAssn_satisfies_fullSpec (c : SymmBreak.C3Zeros n s) :
    cliqueToAssn c.kclique ⊨ fullSpec := by
  unfold fullSpec
  simp
  refine ⟨cliqueToAssn_satisfies_baseSpec _, ?_, ?_, ?_⟩
  · simp [c0_c1_spec, cliqueToAssn]
  · simp [c3_sorted_spec, cliqueToAssn]
    intros; apply c.c3_zeros_sorted
    · assumption
    · omega
  · simp only [
      c3_more_nonzero_spec, add_lt_add_iff_right, cliqueToAssn,
      decide_eq_true_eq]
    rintro j jrange col crange c3_nz_z
    apply c.c3_more_nonzero j (by omega) c3_nz_z col crange

/-- This direction is more complicated, and also we don't need it,
    but we prove it as an interesting aside. -/
theorem clique_of_satisfies_baseSpec {τ : Model.PropAssignment (Vars n s)} :
    open Model.PropPred in τ ⊨ baseSpec → ∃ c : KClique n s, τ = cliqueToAssn c := by
  rintro ⟨coords,twoDiffs,sGaps⟩
  let verts : Finset (KVertex n s) :=
    Finset.univ (α := BitVec n)
    |>.map ⟨fun i => ⟨i,Vector.ofFn fun j => (coords i j).choose⟩
      , by intro; simp⟩
  refine ⟨
    ⟨verts
    ,?isClique,?card⟩
    ,?eqτ⟩
  case card => simp [verts]
  case isClique =>
    rintro ⟨i1,c1⟩ mem1 ⟨i2,c2⟩ mem2 ne
    -- mem1 and mem2 essentially tell us how to interpret τ
    replace mem1 : ∀ j k, τ (Vars.x i1 j k) = true ↔ k = c1[j.val] := by
      intro j k
      have := mem1; simp [verts] at this
      have := congrArg (·[j]) this; simp at this
      have := this ▸ Exists.choose_spec (coords i1 j)
      exact ⟨this.2 k, fun h => h ▸ this.1⟩
    replace mem2 : ∀ j k, τ (Vars.x i2 j k) = true ↔ k = c2[j.val] := by
      intro j k
      have := mem2; simp [verts] at this
      have := congrArg (·[j]) this; simp at this
      have := this ▸ Exists.choose_spec (coords i2 j)
      exact ⟨this.2 k, fun h => h ▸ this.1⟩
    -- now we can show the indices are diff
    replace ne : i1 ≠ i2 := by
      rintro rfl; apply ne; simp; ext1 j hj
      rw [← mem2 ⟨j,hj⟩, mem1]
    -- get the sgap
    specialize sGaps i1 i2 ne
    rcases sGaps with ⟨j1,is_ne_j1,cs_eq_j1⟩
    use j1, is_ne_j1
    constructor
    · -- this is a cool case to step through
      simp; rw [← mem2 j1, ← cs_eq_j1, mem1]
    if just_one_diff : i1 ^^^ i2 = 1#n <<< j1.val then
      specialize twoDiffs i1 i2 j1 just_one_diff
      rcases twoDiffs with ⟨j2,js_ne,k,x_ne⟩
      use j2, js_ne.symm
      rw [Ne, Bool.eq_iff_iff, mem1, mem2] at x_ne
      right; intro; simp_all
    else
      rw [BitVec.eq_of_getElem_eq_iff] at just_one_diff
      simp at just_one_diff
      rcases just_one_diff with ⟨j2,hj2,h⟩
      use ⟨j2,hj2⟩
      rw [Bool.eq_iff_iff, not_iff] at h
      simp at h
      have : j1 ≠ ⟨j2,hj2⟩ := by
        rintro rfl; simp [h] at is_ne_j1
      simp [this]; left
      cases j1; simp_all; omega
  case eqτ =>
    ext ⟨i,j,k⟩
    rw [Bool.eq_iff_iff]
    simp only [cliqueToAssn]
    generalize hcs : KClique.get _ _ = cs
    rw [KClique.get_eq_iff_mem] at hcs
    simp [verts] at hcs; subst hcs
    simp
    have := Exists.choose_spec (coords i j)
    simp at this
    generalize Exists.choose _ = boop at this ⊢
    clear * - this
    aesop

end Spec


section CNF
open VEncCNF Model Vars

/-- ensure that each vertex has a defined coordinate on each dimension -/
def coordinates : VEncCNF (Vars n s) Unit (fun τ =>
    open PropFun in ∀ i j, ∃! k, τ ⊨ .var (x i j k) ) :=
  (for_all (allBitVecs n) fun i =>
    for_all (Array.finRange n) fun j =>
      newCtx s!"exactly one x_{i.toNat},{j}" <|
      let vars := Array.ofFn (fun k => Literal.pos <| Vars.x i j k)
      seq[
        -- at least one of the `c_ij-` variables is true
        Cardinality.atLeastOne vars,
        -- at most one of the `c_ij-` variables is true
        Cardinality.amoPairwise vars
      ]
  ).mapProp (by
    -- annoying boilerplate
    ext τ; simp
    apply forall_congr'; intro i
    apply forall_congr'; intro j
    -- LHS says card is equal to one
    rw [← Nat.le_antisymm_iff, eq_comm, Cardinality.card_eq_one]
    case nodup =>
      simp [List.nodup_ofFn]; intro; simp [LitVar.ext_iff]
    -- wiggle some defs around
    simp [List.mem_ofFn, LitVar.mkPos]
    simp_rw [ExistsUnique, ← exists_and_right]
    aesop
  )



/-- ensure for all pairs where only one coordinate is guaranteed to be different,
that there is a second coordinate which is also different -/
def twoDiffs : VEncCNF (Vars n s) Unit (fun τ =>
    ∀ (i i' : BitVec n) (j : Fin n), i ^^^ i' = .oneAt j → ∃ j' ≠ j, ∃ k, τ (x i j' k) ≠ τ (x i' j' k)) :=
  (for_all (allBitVecs n) fun i =>
    for_all (Array.finRange n) fun j =>
      -- the bitvector which must be different only at coord `j`
      let i' : BitVec n := i ^^^ .oneAt j
      -- this is symmetric so only output the i < i' case
      VEncCNF.guard (i < i') fun h =>
        twoDiffsAt i i' j
  ).mapProp (by
    ext τ; simp
    constructor
    · intro h i i'; revert h
      wlog h_le : i ≤ i'
      · specialize this τ i' i (BitVec.le_total _ _ |>.resolve_left h_le)
        convert this using 3
        · rw [BitVec.xor_comm]
        · simp_rw [eq_comm (a := τ (x i _ _))]
      intro h j i_i'
      have : i < i' := by
        apply BitVec.lt_of_le_ne h_le; rintro rfl
        simpa using congrArg (·[j]) i_i'
      specialize h i j
      simp [← i_i', ← BitVec.xor_assoc, this] at h
      exact h
    · intro h i j h_lt
      apply h
      simp [← BitVec.xor_assoc]
  )
where
  twoDiffsAt (i i' j) : VEncCNF (Vars n s) Unit
    (fun τ => ∃ j' ≠ j, ∃ k, τ (x i j' k) ≠ τ (x i' j' k))
  :=
    (newCtx s!"two diffs c{i.toNat} c{i'.toNat}" <|
    withTemps (Fin n × Fin s)
      (names := some fun (j',k) => toString (AllVars.y i i' j' k)) <|
    seq[
      for_all (Array.finRange n) fun j' =>
        VEncCNF.guard (j' ≠ j) fun _h =>
          for_all (Array.finRange s) fun k =>
            xNeAt i i' j' k
    , addClause (Array.mk (do
        let j' ← List.finRange n
        guard (j' ≠ j)
        let k ← List.finRange s
        return Literal.pos (Sum.inr (j',k))
      ))
    ]).mapProp (by
      ext τ
      simp [Clause.satisfies_iff, _root_.guard, failure]
      constructor
      · rintro ⟨σ,rfl,h1,_,⟨j',j'_ne,k,rfl⟩,h_sat⟩
        simp at h_sat
        use j', j'_ne, k
        specialize h1 j'; simp [j'_ne, h_sat] at h1
        specialize h1 k; simp [h_sat] at h1
        simp [h1]
      · rintro ⟨j',j'_ne,k,h⟩
        use (fun | .inl v => τ v | .inr (_j',_k) => j' = _j' ∧ k = _k)
        refine ⟨?_,?_,?_⟩
        · ext v; simp
        · aesop
        · use Literal.pos (.inr (j',k))
          simp
          use j', j'_ne, k
      )
  xNeAt (i i' j' k) : VEncCNF (Vars n s ⊕ _ × _) Unit
        (fun τ => τ (.inr (j',k)) → τ (.inl <| x i j' k) ≠ τ (.inl <| x i' j' k)) :=
    let temp := Literal.neg (Sum.inr (j',k))
    seq[
      addClause #[temp, Literal.pos <| Sum.inl (Vars.x i j' k), Literal.pos <| Sum.inl (Vars.x i' j' k)],
      addClause #[temp, Literal.neg <| Sum.inl (Vars.x i j' k), Literal.neg <| Sum.inl (Vars.x i' j' k)]]
    |>.mapProp (by
      ext τ; simp [Clause.satisfies_iff, temp]
      generalize τ _ = a; generalize τ _ = b; generalize τ _ = c
      cases a <;> cases b <;> simp
    )


/-- ensures `i` and `i'` have a coord `j` on which the bits differ but colors equal -/
def hasSGap (i i' : BitVec n) : VEncCNF (Vars n s) Unit
      (fun τ => ∃ j, i[j] ≠ i'[j] ∧ ∀ k, τ (x i j k) = τ (x i' j k)) :=
  -- only can consider those `j` for which `i` and `i'` could have an `s`-gap
  (let potentialJs := Array.finRange n |>.filter fun j => i[j] ≠ i'[j]
  newCtx s!"s gap c{i.toNat} c{i'.toNat}" <|
  withTemps (Fin n) (names := some fun j => toString (AllVars.z (s := s) i i' j)) <|
    seq[
      for_all potentialJs fun j =>
        newCtx s!"s gap c{i.toNat} c{i'.toNat} at {j}" <|
        for_all (Array.finRange s) fun k =>
          seq[
            addClause #[Literal.neg (Sum.inr j),
              Literal.pos (Sum.inl (x i j k)), Literal.neg (Sum.inl (x i' j k))],
            addClause #[Literal.neg (Sum.inr j),
              Literal.neg (Sum.inl (x i j k)), Literal.pos (Sum.inl (x i' j k))]
          ]
    , addClause (potentialJs |>.map (Literal.pos <| Sum.inr ·)) ]
  )
  |>.mapProp (by
    ext τ
    simp [Clause.satisfies_iff, -Array.size_finRange]
    constructor
    · rintro ⟨σ, rfl, h_js, j, is_ne_at_j, j_true⟩
      use j, is_ne_at_j
      intro k
      specialize h_js j is_ne_at_j k
      aesop
    · rintro ⟨j,is_ne_at_j,h⟩
      use (fun | .inl v => τ v | .inr _j => _j = j)
      constructor
      · ext v; simp
      · simp +contextual [← imp_iff_not_or, h, is_ne_at_j])

/-- ensures all pairs of vertices have an s-gap  -/
def allSGap : VEncCNF (Vars n s) Unit (fun τ =>
    ∀ i i', i ≠ i' → ∃ j, i[j] ≠ i'[j] ∧ ∀ k, τ (x i j k) = τ (x i' j k)) :=
  (for_all (allBitVecs n) fun i =>
    for_all (allBitVecs n) fun i' =>
      guard (i < i') fun _h => hasSGap i i'
  ).mapProp (by
    ext τ; simp
    constructor
    · intro h i i' is_ne
      wlog h_lt : i < i'
      · replace is_ne := Ne.symm is_ne
        replace h_lt := BitVec.lt_of_le_ne (BitVec.not_lt.mp h_lt) is_ne
        specialize this τ h i' i is_ne h_lt
        simp_rw [eq_comm (a := i[_]'_), eq_comm (a := τ (x i _ _))]
        exact this
      simpa [h_lt] using h i i'
    · intro h i i' i_lt
      exact h i i' (BitVec.ne_of_lt ‹_›)
  )

def baseEncoding (n s) : VEncCNF (Vars n s) Unit baseSpec :=
  seq[
    coordinates,
    twoDiffs,
    allSGap
  ] |>.mapProp (by ext τ; simp [baseSpec])

def c0_c1 (n s) : VEncCNF (Vars (n+2) (s+2)) Unit c0_c1_spec :=
  seq[
    -- c0 = (0, 0, 0, 0, 0, 0*)
    for_all (Array.finRange _) fun j =>
      unit <| .pos (x 0 j SymmBreak.TwoCubes.c0_colors[j])
  , -- c1 = (0, 1, 0, 0, 0, 0*)
    for_all (Array.finRange _) fun j =>
      unit <| .pos (x 1 j SymmBreak.TwoCubes.c1_colors[j])
  ]
  |>.mapProp (by ext τ; simp [c0_c1_spec])

def c3_sorted (n s) : VEncCNF (Vars (n+2) (s+2)) Unit c3_sorted_spec :=
  (for_all (Array.finRange (n+2)) fun j =>
    VEncCNF.guard (2 ≤ j.val ∧ j.val+1 < n+2) fun h =>
      addClause #[Literal.neg <| x 3 ⟨j,by omega⟩ 0
                , Literal.pos <| x 3 ⟨j+1,by omega⟩ 0]
  ).mapProp (by
    ext τ; simp [-Bool.not_eq_true, c3_sorted_spec, Clause.satisfies_iff]
    constructor
    · intro h j range; specialize h ⟨j,by omega⟩ (by simp; omega)
      simp only [← imp_iff_not_or] at h
      exact h
    · intro h j range
      rw [← imp_iff_not_or]; apply h; omega
  )

-- TODO(JG): this def is SUPER slow, fix it somehow
seal BitVec.ofNat in
def c3_more_nonzero (n s) : VEncCNF (Vars (n+2) (s+2)) Unit c3_more_nonzero_spec :=
  ( for_all (Array.finRange (n+2)) fun j =>
    VEncCNF.guard (2 ≤ j.val ∧ j.val + 1 < n+2) fun h =>
      for_all (Array.finRange (n+2)) fun col =>
      VEncCNF.guard (2 ≤ col.val ∧ col.val ≤ j.val) fun cr =>
        aux j h col cr
  ).mapProp (by
    ext τ; simp only [Array.mem_finRange, add_lt_add_iff_right,
      BitVec.ofNat_eq_ofNat, Fin.eta, and_imp, forall_const, c3_more_nonzero_spec]
    constructor
    · intro h j jr col cr
      exact h ⟨j,by omega⟩ (by dsimp; omega) ⟨col,by omega⟩ (by dsimp; omega)
    · intro h j jr col cr
      exact h j.val jr col.val cr
  )
where
  aux (j : Nat) (jr : 2 ≤ j ∧ j + 1 < n+2)
      (col : Nat) (cr : 2 ≤ col ∧ col ≤ j)
      : VEncCNF (Vars (n+2) (s+2)) Unit (fun τ =>
        ¬ τ (x 3 ⟨j,by omega⟩ 0) ∧ τ (x 3 ⟨j+1,by omega⟩ 0) →
        (∀ (_j : Nat) (range : 2 ≤ _j ∧ _j ≤ j),
          ¬ τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))
        → (∀ (_j : Nat) (range : j < _j ∧ _j < n + 2),
          τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))
      ) :=
    let idx : BitVec (n+2) := (SymmBreak.C3Zeros.X col (by omega))
    VEncCNF.andImplyAnd
      (hyps :=
        #[Literal.neg (x 3 ⟨j,by omega⟩ 0), Literal.pos (x 3 ⟨j+1,by omega⟩ 0)]
        ++ Array.ofFn (n := (j+1)-2) fun _j => Literal.neg <| x idx ⟨2+_j,by omega⟩ 0)
      (concs :=
        Array.ofFn (n := (n+2)-(j+1)) fun _j => Literal.pos <| x idx ⟨j+1+_j,by omega⟩ 0)
    |>.mapProp (by
      ext τ
      simp +contextual [-Bool.not_eq_true,-BitVec.ofNat_eq_ofNat,or_imp,forall_and]
      apply imp_congr_right; rintro -; apply imp_congr_right; rintro -
      constructor
      · rintro h cX_nz
        specialize h (fun a => cX_nz _ (by omega))
        intro j' range'
        convert h ⟨j'-(j+1),by omega⟩
        dsimp; omega
      · intro h hyps j'
        apply h ?_ _ (by omega)
        intro j' range'
        convert hyps ⟨j'-2,by omega⟩
        dsimp; omega)

def fullEncoding (n s) : VEncCNF (Vars n s) Unit fullSpec :=
  seq[
    baseEncoding n s
  , VEncCNF.guard (n ≥ 2 ∧ s ≥ 2) fun h =>
      seq[
        c0_c1 (n-2) (s-2)
      , c3_sorted (n-2) (s-2)
      , c3_more_nonzero (n-2) (s-2)
      ]
      |>.castVar (by congr <;> simp [h])
  ]
  |>.mapProp (by
    ext τ
    unfold fullSpec
    simp; rintro -
    match s with
    | 0 | 1 => simp
    | s+2 =>
    match n with
    | 0 | 1 => simp
    | n+2 => simp
  )

end CNF

def AllVars.reorder (f : Fin n ≃ Fin n) : AllVars n s → AllVars n s :=
  let iMap : BitVec n → BitVec n := fun i => BitVec.ofFn ( i[f.symm ·] )
  fun
  | .x i j k => .x (iMap i) (f j) k
  | .y i i' j k =>
    -- the y vars are symmetric in the `i`s, and we only use the one where `i` < `i'`
    -- so we need to figure out which one is which after the mapping
    let (i1,i2) := if iMap i < iMap i' then (iMap i, iMap i') else (iMap i', iMap i)
    .y i1 i2 (f j) k
  | .z i i' j =>
    -- see above
    let (i1,i2) := if iMap i < iMap i' then (iMap i, iMap i') else (iMap i', iMap i)
    .z i1 i2 (f j)

def AllVars.renumber (f : Fin n → Fin s → Fin s) : AllVars n s → AllVars n s
| .x i j k => .x i j (f j k)
| .y i i' j k => .y i i' j (f j k)
| .z i i' j => .z i i' j

namespace SR

structure Line (n s) where
  c : Clause (Literal (AllVars n s))
  pivot : Literal (AllVars n s)
  true_lits : List (Literal (AllVars n s))
  substs : List (AllVars n s × Literal (AllVars n s))

def mkLine (c : Clause (Literal (AllVars n s))) (hc : c.size > 0 := by simp)
        (substs : List (AllVars n s × Literal (AllVars n s))) : Line n s :=
  have : Inhabited (Literal <| AllVars n s) := ⟨c[0]⟩
  -- we need to pick a pivot `p ∈ c` such that `substs(p) ∉ c`
  let pivot := c.find? (fun p =>
      match substs.find? (·.1 = p.toVar) with
      | some (_,mapped_p) => c.all (·.toVar ≠ mapped_p.toVar)
      | none => true
    ) |>.get!
  -- now let's ensure pivot is at the front
  let c := #[pivot] ++ c.filter (· != pivot)
  -- If pivot is not already mapped in `substs`, map it to itself
  -- to avoid the default inclusion of the pivot in true_lits
  let substs :=
    if substs.any (·.1 = pivot.toVar) then
      substs
    else
      (pivot.toVar, .pos pivot.toVar) :: substs
  { c, pivot, true_lits := [], substs }

/-- Given a mapping, this returns all the substitutions for all "changed" variables -/
def substsOfMap (f : AllVars n s → AllVars n s) : List (AllVars n s × Literal (AllVars n s)) := Id.run do
  let subst : AllVars n s → _ × _ := fun v => (v, Literal.pos (f v))

  let mut substs : Array (AllVars n s × Literal (AllVars n s)) := #[]
  -- x_i,j,k <-> x_map(i),j',k
  for i in allBitVecs n do
    for j in Array.finRange n do
      for k in Array.finRange s do
        substs := substs.push <| subst <| .x i j  k

  -- y_i,i',j,k <-> y_map(i),map(i'),j',k
  for i in allBitVecs n do
    for jdiff in Array.finRange n do
      let i' := i ^^^ BitVec.oneAt jdiff
      if i < i' then
        for j in Array.finRange n do
          if j ≠ jdiff then
            for k in Array.finRange s do
              substs := substs.push <| subst <| .y i i' j  k

  -- z_i,i',j <-> z_map(i),map(i'),j'
  for i in allBitVecs n do
    for i' in allBitVecs n do
      if i < i' then
        for j in Array.finRange n do
          substs := substs.push <| subst <| .z i i' j

  return substs.filter (fun (v,l) => v ≠ l.toVar) |>.toList

def reorderSubsts {s} (j j' : Fin n) :=
  substsOfMap (s := s) <| AllVars.reorder <| Equiv.swap j j'

def renumberSubsts (j : Fin n) (k k' : Fin s) := Id.run do
  substsOfMap <| AllVars.renumber (fun j' => if j' = j then Equiv.swap k k' else Equiv.refl _)

/-! #### SR Proof

We can add so many facts!
-/

def bound (idx : BitVec n) (ltK : Nat) : Array (Line n s) := Id.run do
  let mut lines := #[]
  for hj : j in [2:n] do
    let j : Fin n := ⟨j,hj.upper⟩
    for hk : k in [ltK:s] do
      have : ltK < s := Nat.lt_of_le_of_lt hk.lower hk.upper
      let k : Fin s := ⟨k,hk.upper⟩
      lines := lines.push <|
        mkLine
          (c := #[ Literal.neg <| .x idx j k ])
          (substs := renumberSubsts j ⟨ltK-1,by omega⟩ k)
  return lines

/-! ##### Renumber c3

for all j in [2:n], assume `c3[j] < 2`
-/

def c3_bounds : Array (Line n s) := bound 3 2

/-! ##### Renumber cX

Now we constrain the special indices below `c3`,
so there are fewer cases to eliminate via matrix symmetries.

-/

def cX_bounds : Array (Line n s) := Id.run do
  let mut lines := #[]

  for hj : j in [2:n] do
    let j : Fin n := ⟨j,hj.upper⟩

    for hi : row in [0:n-2] do
      have : row < n-2 := hi.upper
      let idx : BitVec n :=
        SymmBreak.C3Zeros.X (n := n-2) (row+2) (by omega)
        |>.cast (by omega)

      lines := lines ++ bound idx (row+3)

  return lines


/-! ##### Fix c3[2:5]
Now `c3[2] = c3[3] = 1` by unit prop.
We can also show `c3[4] = 1` with some quick casework.
We do not know about `c3[5]` and `c3[6]` yet, but can case on them down the road.
-/

def c3_fixed : Array (Line n s) :=
  if h : n ≥ 5 ∧ s ≥ 2 then
    let one : Fin s := ⟨1,by omega⟩
    let two : Fin n := ⟨2,by omega⟩
    let three : Fin n := ⟨3,by omega⟩
    let four : Fin n := ⟨4,by omega⟩
    #[
      mkLine #[ .pos <| .x 3 two one ] (substs := [])
    , mkLine #[ .pos <| .x 3 three one ] (substs := [])
    , mkLine #[ .neg <| .x 7 three one, .pos <| .x 3 four one ] (substs := [])
    , mkLine #[ .neg <| .x 11 two one, .pos <| .x 3 four one ] (substs := [])
    , mkLine #[ .pos <| .x 3 four one ] (substs := [])
    ]
  else #[]


/-! ##### Matrix symmetries

-/

def canonicalMats := SymmBreak.Matrix.matsUpTo 3

def autoToMap (a : SymmBreak.Matrix.Auto m) (h : 2+m ≤ n) : AllVars n s → AllVars n s :=
  match a with
  | .renumber f =>
      AllVars.renumber fun j k =>
        if h' : 2 ≤ j.val ∧ j.val < 2+m then
          let x := f ⟨j-2,by omega⟩ k
          if h'' : x < s then
            ⟨x,h''⟩
          else
            have : Inhabited (Fin s) := ⟨k⟩
            panic! "renumber maps outside s"
        else
          k
  | .reorder p =>
      AllVars.reorder <|
        Equiv.Perm.extendDomain (p := fun j => 2 ≤ j.val ∧ j.val < 2+m)
          p
          { toFun := (⟨⟨·.val+2,by omega⟩,by simp; omega⟩)
            invFun := (⟨·.val-2,by omega⟩)
            left_inv := by intro; simp, right_inv := by rintro ⟨a,b⟩; ext; simp; omega
          }
  | .trans a1 a2 =>
      fun x => x |> autoToMap a1 h |> autoToMap a2 h
  | .lift a1 =>
      autoToMap a1 (Nat.le_of_lt h)

def matSymms : Array (Line n s) := Id.run do
  let mut lines := #[]

  if h : n ≥ 5 ∧ s ≥ n then
    have : NeZero s := ⟨by omega⟩
    for h' : matSize in [3,2] do
      have : matSize < 4 := by simp at h'; omega
      for (k,v) in (canonicalMats.get matSize).map do
        match v with
        | .canon _ => pure ()
        | .noncanon _ auto =>
          let clause :=
            Array.finRange matSize |>.flatMap fun (row : Fin matSize) =>
              Array.ofFn (n := matSize) fun col =>
                let idx : BitVec n :=
                  SymmBreak.C3Zeros.X (n := n-2) (row+2) (by omega)
                  |>.cast (by omega)
                let dim : Fin n := ⟨col+2, by omega⟩
                let color : Fin s := Fin.ofNat' s k.data[row][col]
                .neg (.x idx dim color)
          let subst := substsOfMap <| autoToMap auto (by omega)
          if h'' : clause.size > 0 then
            lines := lines.push <| mkLine clause h'' subst
          else
            panic! s!"clause empty??"

  return lines

def boop (s : Nat) (a : SymmBreak.Matrix.Auto m) (prec : Nat) : Std.Format :=
  match a with
  | .renumber f =>
    let vec := Array.ofFn fun j =>
      Array.ofFn (n := s) fun k =>
        f j k
    .join [".renumber ", .line, Repr.reprPrec vec prec]
  | .reorder p =>
    let vec := Array.finRange _ |>.map p
    .join [".reorder ", Repr.reprPrec vec prec]
  | .trans a1 a2 =>
    .nestD <| .join [".trans ", .line, boop s a1 prec, .line, boop s a2 prec]
  | .lift a1 =>
    .join [".lift ", boop s a1 prec]

--#eval
--  IO.println <| autoToMap (m := 3) (n := 6) (s := 6) (
--    --.trans
--      (.reorder (Equiv.Perm.setAll [(0,2),(1,0),(2,1)]))
--    --  (.reorder (Equiv.Perm.setAll [(0,1),(1,0),(2,2)]))
--  ) (by omega) <| .x 4 4 0
--
#eval match canonicalMats.get 3 |>.map.toArray[36]! with
| (_, .canon _) =>
  IO.println "canon"
| (x, .noncanon _ a) => do
  let substs : List (AllVars 6 6 × Literal (AllVars 6 6)) := autoToMap a (by omega)
    |> substsOfMap (n := 6) (s := 6)
    |>.filter (fun | (.x i j _, _) => 2 ≤ j ∧ j < 5 ∧ i ∈ [7,11,19] | _ => false)
  IO.println <| x
  IO.println <| boop 6 a 0
  IO.println <| a.toFun x
  IO.println <| substs

def all (n s) : Array (Line n s) :=
  c3_bounds
  ++ matSymms
  ++ cX_bounds
  ++ c3_fixed

end SR

namespace Cubes

open Vars

def matrixCubes (hn : n ≥ 5) (hs : s ≥ 4) : List (Clause <| Literal (Vars n s)) :=
  let matrixList := (SR.canonicalMats.get 3).canonical.toList
  let idxs := #[7, 11, 19]
  matrixList.map fun m =>
    Array.mk <| List.flatten <|
      List.ofFn fun r : Fin 3 => List.ofFn fun c : Fin 3 =>
        let mval : Fin s := @Fin.ofNat' s (by apply NeZero.mk; omega) m.data[r][c]
        .pos (x idxs[r] ⟨2+c, by omega⟩ mval)

def triangle (L : List α) (n : Nat) : List (Vector α n) :=
  aux L n |>.map (·.reverse)
where aux (L : List α) (n : Nat) : List (Vector α n) :=
  match n with
  | 0 => [⟨#[], by simp⟩]
  | n+1 =>
    L.tails.flatMap (fun
      | []     => []
      | hd::tl =>
        aux (hd::tl) n |>.map (·.push hd)
    )

def canonicalColumn (start : Fin s) (len : Nat) : List (Vector (Fin s) len) :=
  aux start len |>.map (Vector.reverse)
where aux (start : Fin s) (len) : List (Vector (Fin s) len) :=
  have : NeZero s := ⟨fun h => (h ▸ start).elim0⟩
  match len with
  | 0 => [⟨#[],by simp⟩]
  | len+1 => do
    let tail := aux start len
    (List.range (start+1)).flatMap (fun hd =>
      let hd : Fin s := hd
      tail.map (·.push hd)) ++
    (aux (start+1) len).map (fun tl =>
      tl.push (Fin.ofNat' s (start+1)))

def canonicalColumns (n : Nat) (len : Nat) (hs : s > 0) : List (Vector (Vector (Fin s) len) n) :=
  let cols := canonicalColumn (s := s) ⟨0,hs⟩ len
  triangle cols n

def lastColsCubes (hn : n ≥ 5) (hs : s ≥ 4) : List (Clause <| Literal (Vars n s)) :=
  let idxs := #[3, 7, 11, 19]
  let colsList := canonicalColumns (n-5) idxs.size (by omega)
  colsList.map fun cols =>
    let cube := Array.flatten (
      Array.ofFn fun r => Array.ofFn (n := n-5) fun c =>
        .pos <| x idxs[r] ⟨c+5, by omega⟩ cols[c][r])
    cube


def allCubes : List (Clause <| Literal <| Vars n s) :=
  if hn : n ≥ 5 then
    if hs : s ≥ 4 then
      matrixCubes hn hs ×ˢ lastColsCubes hn hs
      |>.map (fun (a,b) => a ++ b)
    else []
  else []

end Cubes
