/-
Copyright (c) 2024 The Trestle Contributors.
Released under the Apache License v2.0; see LICENSE for full text.

Authors: James Gallicchio
-/

import Trestle.Encode
import Trestle.Data.Cube
import Trestle.Solver.Dimacs
import Trestle.Upstream.IndexTypeInstances

import Experiments.Keller.KellerGraph
import Experiments.Keller.SymmBreak.TwoCubes
import Experiments.Keller.SymmBreak.C3Zeros
import Experiments.Keller.SymmBreak.MatrixGen

namespace Keller.Encoding

open Trestle Encode

inductive Vars (n s : Nat)
-- coordinates of each of the 2^n clique nodes
| x (i : BitVec n) (j : Fin n) (k : Fin s)
deriving IndexType, Hashable, Ord

instance : ToString (Vars n s) where
  toString | Vars.x i j k => s!"x{i.toNat},{j},{k}"

inductive AllVars (n s : Nat)
| x (i : BitVec n) (j : Fin n) (k : Fin s)
| y (i i' : BitVec n) (j : Fin n) (k : Fin s)
| z (i i' : BitVec n) (j : Fin n)
deriving DecidableEq

instance [Inhabited (Fin n)] [Inhabited (Fin s)] : Inhabited (AllVars n s) where
  default := .x 0 default default

instance : ToString (AllVars n s) where
  toString
    | .x i j k    => s!"x{i.toNat},{j},{k}"
    | .y i i' j k => s!"y{i.toNat},{i'.toNat},{j},{k}"
    | .z i i' j   => s!"z{i.toNat},{i'.toNat},{j}"

def allBitVecs (n) : Array (BitVec n) := Array.ofFn (BitVec.ofFin)

@[simp] theorem mem_allBitVecs (x : BitVec n) : x ∈ allBitVecs n := by
  simp [allBitVecs]



section Spec

open Vars

def baseSpec : Model.PropPred (Vars n s) :=
  (fun τ =>
    -- type 1 clauses in paper
    (∀ (i : BitVec n) (j : Fin n), ∃! k, τ (x i j k)) ∧
    -- type 2 clauses in paper
    (∀ (i i' : BitVec n) (j : Fin n), i ^^^ i' = BitVec.oneAt j →
        ∃ j', j' ≠ j ∧ ∃ k, τ (x i j' k) ≠ τ (x i' j' k)) ∧
    -- type 5/6 clauses in paper
    (∀ (i i' : BitVec n), i ≠ i' → ∃ j, i[j] ≠ i'[j] ∧ ∀ (k : Fin s), τ (x i j k) = τ (x i' j k)))

def c0_c1_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ =>
    (∀ j, τ (x 0 j SymmBreak.TwoCubes.c0_colors[j])) ∧
    (∀ j, τ (x 1 j SymmBreak.TwoCubes.c1_colors[j]))

def c3_sorted_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ => ∀ (j : Nat) (range : 2 ≤ j ∧ j + 1 < n+2),
    τ (x 3 ⟨j,by omega⟩ 0) → τ (x 3 ⟨j+1,by omega⟩ 0)

def c3_more_nonzero_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ =>
    ∀ (j : Nat) (range : 2 ≤ j ∧ j + 1 < n + 2)
      (col : Nat) (cr : 2 ≤ col ∧ col ≤ j),
      ¬ τ (x 3 ⟨j,by omega⟩ 0) ∧ τ (x 3 ⟨j+1,by omega⟩ 0) →
      (∀ (_j : Nat) (range : 2 ≤ _j ∧ _j ≤ j),
        ¬ τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))
      → (∀ (_j : Nat) (range : j < _j ∧ _j < n + 2),
        τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))


def fullSpec : Model.PropPred (Vars n s) :=
  fun τ =>
    baseSpec τ ∧
    (match n,s with
    | _+2, _+2 => c0_c1_spec τ ∧ c3_sorted_spec τ ∧ c3_more_nonzero_spec τ
    | _,_ => True)


def cliqueToAssn (c : KClique n s) : Model.PropAssignment (Vars n s) :=
  fun | .x i j k => (c.get i)[j] = k

def assnToVertices (τ : Model.PropAssignment (Vars n s)) : Set (KVertex n s) :=
  fun ⟨i,cs⟩ => ∀ j, τ (x i j (cs[j]))

open Model.PropPred in
/-- `baseSpec` is satisfied by the assignment generated by `c` -/
theorem cliqueToAssn_satisfies_baseSpec (c : KClique n s) :
    cliqueToAssn c ⊨ baseSpec := by
  unfold baseSpec cliqueToAssn
  refine ⟨?_,?_,?_⟩
  · -- this should just be simp but for some reason existsUnique_eq' is not applying
    intro i j; simp only [Model.PropFun.satisfies_var, decide_eq_true_eq]; apply existsUnique_eq' (a' := (c.get i)[j])
  · intro i i' j is_xor
    have ⟨_,j2,js_ne,h⟩ := c.get_adj_of_xor_eq j is_xor
    use j2, js_ne, (c.get i')[j2]
    simpa using h
  · intro i i' is_ne
    have ⟨j1,is_ne_j1,cs_eq_j1,_⟩ := c.get_adj is_ne
    use j1, is_ne_j1
    simpa using cs_eq_j1

open Model.PropPred in
/-- `fullSpec` is satisfied by a `C3Zeros` instance -/
theorem cliqueToAssn_satisfies_fullSpec (c : SymmBreak.C3Zeros n s) :
    cliqueToAssn c.kclique ⊨ fullSpec := by
  unfold fullSpec
  simp
  refine ⟨cliqueToAssn_satisfies_baseSpec _, ?_, ?_, ?_⟩
  · simp [c0_c1_spec, cliqueToAssn]
  · simp [c3_sorted_spec, cliqueToAssn]
    intros; apply c.c3_zeros_sorted
    · assumption
    · omega
  · simp only [
      c3_more_nonzero_spec, add_lt_add_iff_right, cliqueToAssn,
      decide_eq_true_eq]
    rintro j jrange col crange c3_nz_z
    apply c.c3_more_nonzero j (by omega) c3_nz_z col crange

/-- This direction is more complicated, and also we don't need it,
    but we prove it as an interesting aside. -/
theorem clique_of_satisfies_baseSpec {τ : Model.PropAssignment (Vars n s)} :
    open Model.PropPred in τ ⊨ baseSpec → ∃ c : KClique n s, τ = cliqueToAssn c := by
  rintro ⟨coords,twoDiffs,sGaps⟩
  let verts : Finset (KVertex n s) :=
    Finset.univ (α := BitVec n)
    |>.map ⟨fun i => ⟨i,Vector.ofFn fun j => (coords i j).choose⟩
      , by intro; simp⟩
  refine ⟨
    ⟨verts
    ,?isClique,?card⟩
    ,?eqτ⟩
  case card => simp [verts]
  case isClique =>
    rintro ⟨i1,c1⟩ mem1 ⟨i2,c2⟩ mem2 ne
    -- mem1 and mem2 essentially tell us how to interpret τ
    replace mem1 : ∀ j k, τ (Vars.x i1 j k) = true ↔ k = c1[j.val] := by
      intro j k
      have := mem1; simp [verts] at this
      have := congrArg (·[j]) this; simp at this
      have := this ▸ Exists.choose_spec (coords i1 j)
      exact ⟨this.2 k, fun h => h ▸ this.1⟩
    replace mem2 : ∀ j k, τ (Vars.x i2 j k) = true ↔ k = c2[j.val] := by
      intro j k
      have := mem2; simp [verts] at this
      have := congrArg (·[j]) this; simp at this
      have := this ▸ Exists.choose_spec (coords i2 j)
      exact ⟨this.2 k, fun h => h ▸ this.1⟩
    -- now we can show the indices are diff
    replace ne : i1 ≠ i2 := by
      rintro rfl; apply ne; simp; ext1 j hj
      rw [← mem2 ⟨j,hj⟩, mem1]
    -- get the sgap
    specialize sGaps i1 i2 ne
    rcases sGaps with ⟨j1,is_ne_j1,cs_eq_j1⟩
    use j1, is_ne_j1
    constructor
    · -- this is a cool case to step through
      simp; rw [← mem2 j1, ← cs_eq_j1, mem1]
    if just_one_diff : i1 ^^^ i2 = 1#n <<< j1.val then
      specialize twoDiffs i1 i2 j1 just_one_diff
      rcases twoDiffs with ⟨j2,js_ne,k,x_ne⟩
      use j2, js_ne.symm
      rw [Ne, Bool.eq_iff_iff, mem1, mem2] at x_ne
      right; intro; simp_all
    else
      rw [BitVec.eq_of_getElem_eq_iff] at just_one_diff
      simp at just_one_diff
      rcases just_one_diff with ⟨j2,hj2,h⟩
      use ⟨j2,hj2⟩
      rw [Bool.eq_iff_iff, not_iff] at h
      simp at h
      have : j1 ≠ ⟨j2,hj2⟩ := by
        rintro rfl; simp [h] at is_ne_j1
      simp [this]; left
      cases j1; simp_all; omega
  case eqτ =>
    ext ⟨i,j,k⟩
    rw [Bool.eq_iff_iff]
    simp only [cliqueToAssn]
    generalize hcs : KClique.get _ _ = cs
    rw [KClique.get_eq_iff_mem] at hcs
    simp [verts] at hcs; subst hcs
    simp
    have := Exists.choose_spec (coords i j)
    simp at this
    generalize Exists.choose _ = boop at this ⊢
    clear * - this
    aesop

end Spec


section CNF
open VEncCNF Model Vars

/-- ensure that each vertex has a defined coordinate on each dimension -/
def coordinates : VEncCNF (Vars n s) Unit (fun τ =>
    open PropFun in ∀ i j, ∃! k, τ ⊨ .var (x i j k) ) :=
  (for_all (allBitVecs n) fun i =>
    for_all (Array.finRange n) fun j =>
      newCtx s!"exactly one x_{i.toNat},{j}" <|
      let vars := Array.ofFn (fun k => Literal.pos <| Vars.x i j k)
      seq[
        -- at least one of the `c_ij-` variables is true
        Cardinality.atLeastOne vars,
        -- at most one of the `c_ij-` variables is true
        Cardinality.amoPairwise vars
      ]
  ).mapProp (by
    -- annoying boilerplate
    ext τ; simp
    apply forall_congr'; intro i
    apply forall_congr'; intro j
    -- LHS says card is equal to one
    rw [← Nat.le_antisymm_iff, eq_comm, Cardinality.card_eq_one]
    case nodup =>
      simp [List.nodup_ofFn]; intro; simp [LitVar.ext_iff]
    -- wiggle some defs around
    simp [List.mem_ofFn, LitVar.mkPos]
    simp_rw [ExistsUnique, ← exists_and_right]
    aesop
  )



/-- ensure for all pairs where only one coordinate is guaranteed to be different,
that there is a second coordinate which is also different -/
def twoDiffs : VEncCNF (Vars n s) Unit (fun τ =>
    ∀ (i i' : BitVec n) (j : Fin n), i ^^^ i' = .oneAt j → ∃ j' ≠ j, ∃ k, τ (x i j' k) ≠ τ (x i' j' k)) :=
  (for_all (allBitVecs n) fun i =>
    for_all (Array.finRange n) fun j =>
      -- the bitvector which must be different only at coord `j`
      let i' : BitVec n := i ^^^ .oneAt j
      -- this is symmetric so only output the i < i' case
      VEncCNF.guard (i < i') fun h =>
        twoDiffsAt i i' j
  ).mapProp (by
    ext τ; simp
    constructor
    · intro h i i'; revert h
      wlog h_le : i ≤ i'
      · specialize this τ i' i (BitVec.le_total _ _ |>.resolve_left h_le)
        convert this using 3
        · rw [BitVec.xor_comm]
        · simp_rw [eq_comm (a := τ (x i _ _))]
      intro h j i_i'
      have : i < i' := by
        apply BitVec.lt_of_le_ne h_le; rintro rfl
        simpa using congrArg (·[j]) i_i'
      specialize h i j
      simp [← i_i', ← BitVec.xor_assoc, this] at h
      exact h
    · intro h i j h_lt
      apply h
      simp [← BitVec.xor_assoc]
  )
where
  twoDiffsAt (i i' j) : VEncCNF (Vars n s) Unit
    (fun τ => ∃ j' ≠ j, ∃ k, τ (x i j' k) ≠ τ (x i' j' k))
  :=
    (newCtx s!"two diffs c{i.toNat} c{i'.toNat}" <|
    withTemps (Fin n × Fin s)
      (names := some fun (j',k) => toString (AllVars.y i i' j' k)) <|
    seq[
      for_all (Array.finRange n) fun j' =>
        VEncCNF.guard (j' ≠ j) fun _h =>
          for_all (Array.finRange s) fun k =>
            xNeAt i i' j' k
    , addClause (Array.mk (do
        let j' ← List.finRange n
        guard (j' ≠ j)
        let k ← List.finRange s
        return Literal.pos (Sum.inr (j',k))
      ))
    ]).mapProp (by
      ext τ
      simp [Clause.satisfies_iff, _root_.guard, failure]
      constructor
      · rintro ⟨σ,rfl,h1,_,⟨j',j'_ne,k,rfl⟩,h_sat⟩
        simp at h_sat
        use j', j'_ne, k
        specialize h1 j'; simp [j'_ne, h_sat] at h1
        specialize h1 k; simp [h_sat] at h1
        simp [h1]
      · rintro ⟨j',j'_ne,k,h⟩
        use (fun | .inl v => τ v | .inr (_j',_k) => j' = _j' ∧ k = _k)
        refine ⟨?_,?_,?_⟩
        · ext v; simp
        · aesop
        · use Literal.pos (.inr (j',k))
          simp
          use j', j'_ne, k
      )
  xNeAt (i i' j' k) : VEncCNF (Vars n s ⊕ _ × _) Unit
        (fun τ => τ (.inr (j',k)) → τ (.inl <| x i j' k) ≠ τ (.inl <| x i' j' k)) :=
    let temp := Literal.neg (Sum.inr (j',k))
    seq[
      addClause #[temp, Literal.pos <| Sum.inl (Vars.x i j' k), Literal.pos <| Sum.inl (Vars.x i' j' k)],
      addClause #[temp, Literal.neg <| Sum.inl (Vars.x i j' k), Literal.neg <| Sum.inl (Vars.x i' j' k)]]
    |>.mapProp (by
      ext τ; simp [Clause.satisfies_iff, temp]
      generalize τ _ = a; generalize τ _ = b; generalize τ _ = c
      cases a <;> cases b <;> simp
    )


/-- ensures `i` and `i'` have a coord `j` on which the bits differ but colors equal -/
def hasSGap (i i' : BitVec n) : VEncCNF (Vars n s) Unit
      (fun τ => ∃ j, i[j] ≠ i'[j] ∧ ∀ k, τ (x i j k) = τ (x i' j k)) :=
  -- only can consider those `j` for which `i` and `i'` could have an `s`-gap
  (let potentialJs := Array.finRange n |>.filter fun j => i[j] ≠ i'[j]
  newCtx s!"s gap c{i.toNat} c{i'.toNat}" <|
  withTemps (Fin n) (names := some fun j => toString (AllVars.z (s := s) i i' j)) <|
    seq[
      for_all potentialJs fun j =>
        newCtx s!"s gap c{i.toNat} c{i'.toNat} at {j}" <|
        for_all (Array.finRange s) fun k =>
          seq[
            addClause #[Literal.neg (Sum.inr j),
              Literal.pos (Sum.inl (x i j k)), Literal.neg (Sum.inl (x i' j k))],
            addClause #[Literal.neg (Sum.inr j),
              Literal.neg (Sum.inl (x i j k)), Literal.pos (Sum.inl (x i' j k))]
          ]
    , addClause (potentialJs |>.map (Literal.pos <| Sum.inr ·)) ]
  )
  |>.mapProp (by
    ext τ
    simp [Clause.satisfies_iff, -Array.size_finRange]
    constructor
    · rintro ⟨σ, rfl, h_js, j, is_ne_at_j, j_true⟩
      use j, is_ne_at_j
      intro k
      specialize h_js j is_ne_at_j k
      aesop
    · rintro ⟨j,is_ne_at_j,h⟩
      use (fun | .inl v => τ v | .inr _j => _j = j)
      constructor
      · ext v; simp
      · simp +contextual [← imp_iff_not_or, h, is_ne_at_j])

/-- ensures all pairs of vertices have an s-gap  -/
def allSGap : VEncCNF (Vars n s) Unit (fun τ =>
    ∀ i i', i ≠ i' → ∃ j, i[j] ≠ i'[j] ∧ ∀ k, τ (x i j k) = τ (x i' j k)) :=
  (for_all (allBitVecs n) fun i =>
    for_all (allBitVecs n) fun i' =>
      guard (i < i') fun _h => hasSGap i i'
  ).mapProp (by
    ext τ; simp
    constructor
    · intro h i i' is_ne
      wlog h_lt : i < i'
      · replace is_ne := Ne.symm is_ne
        replace h_lt := BitVec.lt_of_le_ne (BitVec.not_lt.mp h_lt) is_ne
        specialize this τ h i' i is_ne h_lt
        simp_rw [eq_comm (a := i[_]'_), eq_comm (a := τ (x i _ _))]
        exact this
      simpa [h_lt] using h i i'
    · intro h i i' i_lt
      exact h i i' (BitVec.ne_of_lt ‹_›)
  )

def baseEncoding (n s) : VEncCNF (Vars n s) Unit baseSpec :=
  seq[
    coordinates,
    twoDiffs,
    allSGap
  ] |>.mapProp (by ext τ; simp [baseSpec])

def c0_c1 (n s) : VEncCNF (Vars (n+2) (s+2)) Unit c0_c1_spec :=
  seq[
    -- c0 = (0, 0, 0, 0, 0, 0*)
    for_all (Array.finRange _) fun j =>
      unit <| .pos (x 0 j SymmBreak.TwoCubes.c0_colors[j])
  , -- c1 = (0, 1, 0, 0, 0, 0*)
    for_all (Array.finRange _) fun j =>
      unit <| .pos (x 1 j SymmBreak.TwoCubes.c1_colors[j])
  ]
  |>.mapProp (by ext τ; simp [c0_c1_spec])

def c3_sorted (n s) : VEncCNF (Vars (n+2) (s+2)) Unit c3_sorted_spec :=
  (for_all (Array.finRange (n+2)) fun j =>
    VEncCNF.guard (2 ≤ j.val ∧ j.val+1 < n+2) fun h =>
      addClause #[Literal.neg <| x 3 ⟨j,by omega⟩ 0
                , Literal.pos <| x 3 ⟨j+1,by omega⟩ 0]
  ).mapProp (by
    ext τ; simp [-Bool.not_eq_true, c3_sorted_spec, Clause.satisfies_iff]
    constructor
    · intro h j range; specialize h ⟨j,by omega⟩ (by simp; omega)
      simp only [← imp_iff_not_or] at h
      exact h
    · intro h j range
      rw [← imp_iff_not_or]; apply h; omega
  )

-- TODO(JG): this def is SUPER slow, fix it somehow
seal BitVec.ofNat in
def c3_more_nonzero (n s) : VEncCNF (Vars (n+2) (s+2)) Unit c3_more_nonzero_spec :=
  ( for_all (Array.finRange (n+2)) fun j =>
    VEncCNF.guard (2 ≤ j.val ∧ j.val + 1 < n+2) fun h =>
      for_all (Array.finRange (n+2)) fun col =>
      VEncCNF.guard (2 ≤ col.val ∧ col.val ≤ j.val) fun cr =>
        aux j h col cr
  ).mapProp (by
    ext τ; simp only [Array.mem_finRange, add_lt_add_iff_right,
      BitVec.ofNat_eq_ofNat, Fin.eta, and_imp, forall_const, c3_more_nonzero_spec]
    constructor
    · intro h j jr col cr
      exact h ⟨j,by omega⟩ (by dsimp; omega) ⟨col,by omega⟩ (by dsimp; omega)
    · intro h j jr col cr
      exact h j.val jr col.val cr
  )
where
  aux (j : Nat) (jr : 2 ≤ j ∧ j + 1 < n+2)
      (col : Nat) (cr : 2 ≤ col ∧ col ≤ j)
      : VEncCNF (Vars (n+2) (s+2)) Unit (fun τ =>
        ¬ τ (x 3 ⟨j,by omega⟩ 0) ∧ τ (x 3 ⟨j+1,by omega⟩ 0) →
        (∀ (_j : Nat) (range : 2 ≤ _j ∧ _j ≤ j),
          ¬ τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))
        → (∀ (_j : Nat) (range : j < _j ∧ _j < n + 2),
          τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))
      ) :=
    let idx : BitVec (n+2) := (SymmBreak.C3Zeros.X col (by omega))
    VEncCNF.andImplyAnd
      (hyps :=
        #[Literal.neg (x 3 ⟨j,by omega⟩ 0), Literal.pos (x 3 ⟨j+1,by omega⟩ 0)]
        ++ Array.ofFn (n := (j+1)-2) fun _j => Literal.neg <| x idx ⟨2+_j,by omega⟩ 0)
      (concs :=
        Array.ofFn (n := (n+2)-(j+1)) fun _j => Literal.pos <| x idx ⟨j+1+_j,by omega⟩ 0)
    |>.mapProp (by
      ext τ
      simp +contextual [-Bool.not_eq_true,-BitVec.ofNat_eq_ofNat,or_imp,forall_and]
      apply imp_congr_right; rintro -; apply imp_congr_right; rintro -
      constructor
      · rintro h cX_nz
        specialize h (fun a => cX_nz _ (by omega))
        intro j' range'
        convert h ⟨j'-(j+1),by omega⟩
        dsimp; omega
      · intro h hyps j'
        apply h ?_ _ (by omega)
        intro j' range'
        convert hyps ⟨j'-2,by omega⟩
        dsimp; omega)

def fullEncoding (n s) : VEncCNF (Vars n s) Unit fullSpec :=
  seq[
    baseEncoding n s
  , VEncCNF.guard (n ≥ 2 ∧ s ≥ 2) fun h =>
      seq[
        c0_c1 (n-2) (s-2)
      , c3_sorted (n-2) (s-2)
      , c3_more_nonzero (n-2) (s-2)
      ]
      |>.castVar (by congr <;> simp [h])
  ]
  |>.mapProp (by
    ext τ
    unfold fullSpec
    simp; rintro -
    match s with
    | 0 | 1 => simp
    | s+2 =>
    match n with
    | 0 | 1 => simp
    | n+2 => simp
  )

end CNF



def AllVars.reorder (f : Fin n ≃ Fin n) : AllVars n s → AllVars n s :=
  let iMap : BitVec n → BitVec n := fun i => BitVec.ofFn ( i[f.symm ·] )
  fun
  | .x i j k => .x (iMap i) (f j) k
  | .y i i' j k =>
    -- the y vars are symmetric in the `i`s, and we only use the one where `i` < `i'`
    -- so we need to figure out which one is which after the mapping
    let (i1,i2) := if iMap i < iMap i' then (iMap i, iMap i') else (iMap i', iMap i)
    .y i1 i2 (f j) k
  | .z i i' j =>
    -- see above
    let (i1,i2) := if iMap i < iMap i' then (iMap i, iMap i') else (iMap i', iMap i)
    .z i1 i2 (f j)

def AllVars.renumber (f : Fin n → Fin s → Fin s) : AllVars n s → AllVars n s
| .x i j k => .x i j (f j k)
| .y i i' j k => .y i i' j (f j k)
| .z i i' j => .z i i' j

namespace SR

structure Line (n s) where
  c : Clause (Literal (AllVars n s))
  pivot : Literal (AllVars n s)
  true_lits : List (Literal (AllVars n s))
  substs : List (AllVars n s × Literal (AllVars n s))

instance [Inhabited (AllVars n s)] : Inhabited (Line n s) where
  default := { c := default, pivot := default, true_lits := default, substs := default }

def mkLine (c : Clause (Literal (AllVars n s))) (hc : c.size > 0 := by simp)
        (true_lits : List (Literal (AllVars n s)))
        (substs : List (AllVars n s × Literal (AllVars n s))) : Line n s :=
  have : Inhabited (AllVars n s) := ⟨c[0].toVar⟩
  if true_lits.isEmpty then
    if !substs.isEmpty then
      panic! s!"true_lits empty but substs nonempty?! clause: {c}"
    else
      { c, pivot := c[0], true_lits := [], substs := [] }
  else
  have : Inhabited _ := ⟨c[0]⟩
  -- let's filter out true_lits from substs
  let substs := substs.filter (fun (a,b) => !true_lits.any (·.toVar = a))
  -- we should pick a pivot `p ∈ c` such that `p ∈ true_lits`
  let pivot :=
    match c.find? (true_lits.contains ·) with
    | some p => p
    | none =>
      panic! s!"mkLine could not select a pivot! clause: {c}\ntrue_lits: {true_lits}"
  -- sanity check that the negation of the pivot isn't ALSO in true_lits
  if true_lits.contains (-pivot) then
    panic! s!"true_lits contains literal {pivot} *and* its negation?\nclause: {c}\ntrue_lits: {true_lits}"
  else
  -- now let's ensure pivot is at the front of the clause
  let c := #[pivot] ++ c.filter (· != pivot)
  -- and then filter it out of true_lits
  let true_lits := true_lits.filter (· != pivot)
  { c, pivot, true_lits, substs }

/-- Given a mapping, this returns all the substitutions for all "changed" variables -/
def substsOfMap (f : AllVars n s → AllVars n s) : List (AllVars n s × Literal (AllVars n s)) := Id.run do
  let subst : AllVars n s → _ × _ := fun v => (v, Literal.pos (f v))

  let mut substs : Array (AllVars n s × Literal (AllVars n s)) := #[]
  -- x_i,j,k <-> x_map(i),j',k
  for i in allBitVecs n do
    for j in Array.finRange n do
      for k in Array.finRange s do
        substs := substs.push <| subst <| .x i j  k

  -- y_i,i',j,k <-> y_map(i),map(i'),j',k
  for i in allBitVecs n do
    for jdiff in Array.finRange n do
      let i' := i ^^^ BitVec.oneAt jdiff
      if i < i' then
        for j in Array.finRange n do
          if j ≠ jdiff then
            for k in Array.finRange s do
              substs := substs.push <| subst <| .y i i' j  k

  -- z_i,i',j <-> z_map(i),map(i'),j'
  for i in allBitVecs n do
    for i' in allBitVecs n do
      if i < i' then
        for j in Array.finRange n do
          substs := substs.push <| subst <| .z i i' j

  return substs.filter (fun (v,l) => v ≠ l.toVar) |>.toList

def reorderSubsts {s} (j j' : Fin n) :=
  substsOfMap (s := s) <| AllVars.reorder <| Equiv.swap j j'

def renumberSubsts (j : Fin n) (perm : Equiv.Perm (Fin s)) := Id.run do
  substsOfMap <| AllVars.renumber (fun j' => if j' = j then perm else Equiv.refl _)

/-! ### SR Proof

We can add so many facts!
-/

def bound (idx : BitVec n) (j : Fin n) (ltK : Nat) : Array (Line n s) := Id.run do
  if h : ltK = 0 ∨ ltK > s then
    panic! s!"bound with s = {s}, ltK = {ltK}"
  else
  have : 0 < ltK ∧ ltK ≤ s := by omega
  let k_canonical : Fin s := ⟨ltK-1, by omega⟩

  let mut lines := #[]

  for hk : k_to_block in [ltK:s] do
    have : ltK < s := Nat.lt_of_le_of_lt hk.lower hk.upper
    let k_to_block : Fin s := ⟨k_to_block,hk.upper⟩
    lines := lines.push <|
      mkLine
        (c := #[ Literal.neg <| .x idx j k_to_block ])
        (true_lits := List.finRange s |>.map fun k =>
          Literal.mk (.x idx j k) (k = k_canonical))
        (substs := renumberSubsts j <| Equiv.swap k_canonical k_to_block)

  return lines


/-- #### Renumber c3

for all j in [2:n], assume `c3[j] < 2`
-/
def c3_bounds : Array (Line n s) := Id.run do
  let mut lines := #[]

  for hj : j in [2:n] do
    let j : Fin n := ⟨j,hj.upper⟩
    lines := lines ++ bound 3 j 2

  return lines


/-- #### Fix c3[2:5]
Now `c3[2] = c3[3] = 1` by unit prop.
We can also show `c3[4] = 1` with some quick casework.
We do not know about `c3[5]` and `c3[6]` yet, but can case on them down the road.
-/
def c3_fixed : Array (Line n s) :=
  if h : n ≥ 5 ∧ s ≥ 2 then
    let one : Fin s := ⟨1,by omega⟩
    let two : Fin n := ⟨2,by omega⟩
    let three : Fin n := ⟨3,by omega⟩
    let four : Fin n := ⟨4,by omega⟩
    #[
      mkLine #[ .pos <| .x 3 two one   ] (true_lits := []) (substs := [])
    , mkLine #[ .pos <| .x 3 three one ] (true_lits := []) (substs := [])
    , mkLine #[ .neg <| .x 7 three one, .pos <| .x 3 four one ] (true_lits := []) (substs := [])
    , mkLine #[ .neg <| .x 11 two one,  .pos <| .x 3 four one ] (true_lits := []) (substs := [])
    , mkLine #[ .pos <| .x 3 four one  ] (true_lits := []) (substs := [])
    ]
  else #[]


/-! #### Matrix symmetries

Now we look at `j = 2..n` and the special `cX` indices
(for `n=7`, these are `i=7, 11, 19, 35, 67`).
-/

def cX (row : Nat) (h : n ≥ 2 ∧ row + 2 < n := by omega) : BitVec n :=
  SymmBreak.C3Zeros.X (n := n-2) (row+2) (by omega)
  |>.cast (by omega)

/-- ##### Bound `cX`

In every column `j`, the `r`'th special index `cX[r]`
can be bounded below `3+r`
-/
def cX_bounds (j : Fin n) : Array (Line n s) := Id.run do
  let mut lines := #[]

  for hi : row in [0:n-2] do
    have : row < n-2 := hi.upper
    let idx : BitVec n := cX row

    lines := lines ++ bound idx j (row+3)

  return lines


/-! ##### Increment Sorted Columns

Each column `2 ≤ j` can be constrained to be inc-sorted
on the `cX`s by renumbering.
We iterate over all non-inc-sorted colorings of the column,
blocking each one by mapping to its canonical version.
-/

def generateColorVecs (hdLt : Nat) (len : Nat) : List (Vector (Fin s) len) :=
  match len with
  | 0 => [#v[]]
  | len+1 =>
    let pres := generateColorVecs hdLt len
    let lasts : List (Fin s) :=
      List.range (min s (hdLt+len))
      |>.pmap (⟨·,·⟩) (by simp; omega)
    pres.flatMap fun pre =>
      lasts.map fun last =>
        pre.push last

/-- all the ways we can color the cX indices for columns 2/3/4 -/
def col234_colorings :=
  let colorings := generateColorVecs (hdLt := 3) (len := 3)
  colorings.map fun coloring =>
    let perm := renumberIncr' (s := 5) (L := 0 :: 1 :: (coloring.map (·.val) |>.toList))
      (by simp)
    let renumbered := coloring.map perm
    if coloring == renumbered then
      Sum.inl coloring
    else
      Sum.inr (coloring, perm, renumbered)

/-- all the ways we can color *c3 and cX* indices for columns 5+ -/
def col5_colorings (s) (h : s ≥ 2) :=
  let colorings := generateColorVecs (hdLt := 2) (len := 4)
  colorings.map fun coloring =>
    let perm := renumberIncr' (s := s) (L := 0 :: (coloring.map (·.val) |>.toList))
      (by simp; omega)
    let renumbered := coloring.map perm
    if coloring == renumbered then
      Sum.inl coloring
    else
      Sum.inr (coloring, perm, renumbered)

def col234_incSorted (j : Nat) (hj : 2 ≤ j ∧ j < 5 ∧ j < n) : Array (Line n s) :=
  if h : n < 5 ∨ s < 5 then #[] else
  Id.run do
  let mut lines := #[]

  let j : Fin n := ⟨j, by omega⟩
  have : j.val < 5 := by simp_all [j]

  for (coloring,perm,renumbered) in
      col234_colorings.filterMap (·.getRight?) do

    -- The diagonal element is always 1, so skip assns where that doesn't hold
    if coloring[j.val-2]'(by omega) ≠ 1 then continue

    -- The clause we want to block (negation of `coloring`)
    let clause : Clause (Literal <| AllVars n s) :=
      Array.ofFn (n := 3) fun row =>
        .neg <| .x (cX row) j (coloring[row].castLE (by omega))

    -- Assign all the literals associated with these 3 `(idx,j)` pairs
    let true_lits :=
      List.flatten <|
      List.ofFn (n := 3) fun row =>
        List.ofFn (n := s) fun k =>
          Literal.mk (AllVars.x (cX row) j k) (k.val = renumbered[row].val)

    -- substitute everything else via perm
    let substs := renumberSubsts j (
      (show 5+(s-5) = s by omega) ▸ SymmBreak.Matrix.extendPerm perm.symm (n := s-5))

    lines := lines.push (mkLine clause (hc := by simp [clause]) true_lits substs)

  return lines

def col5_incSorted (j : Nat) (hj : 5 ≤ j ∧ j < n) : Array (Line n s) :=
  if h : n < 5 ∨ s < 5 then #[] else
  Id.run do
  let mut lines := #[]

  let j : Fin n := ⟨j, by omega⟩
  have : j.val ≥ 5 := by simp_all [j]

  for (coloring,perm,renumbered) in
      (col5_colorings s (by omega)).filterMap (·.getRight?) do

    -- The s-gap between c3 and cX[j-2] is always in column `j`,
    -- so skip any colorings where they are unequal
    -- if coloring[0].val ≠ coloring[1+j.val-2]'(by omega) then continue

    -- The clause we want to block (negation of `coloring`)
    let clause : Clause (Literal <| AllVars n s) :=
      Array.ofFn (n := 4) fun row =>
        let idx : BitVec n := if row.val = 0 then 3 else cX (row-1)
        .neg <| .x idx j (coloring[row].castLE (by omega))

    -- Assign all the literals associated with these 3 `(idx,j)` pairs
    let true_lits :=
      List.flatten <|
      List.ofFn (n := 4) fun row =>
        let idx : BitVec n := if row.val = 0 then 3 else cX (row-1)
        List.ofFn (n := s) fun k =>
          Literal.mk (AllVars.x idx j k) (k.val = renumbered[row].val)

    -- substitute everything else via perm
    let substs := renumberSubsts j perm.symm

    lines := lines.push <|
      mkLine clause (hc := by simp [clause]) true_lits substs

  return lines

/-! ##### Canonical matrices

Interpreting the cX indices and columns `j ≥ 2` as a matrix,
we can do column reorderings and renumberings to eliminate many
potential color assignments within this matrix.
-/

def canonicalMats := SymmBreak.Matrix.matsUpTo 3

/-- convert a matrix automorphism (from noncanonical to canononical)
to a mapping (from canonical to noncanonical).

NB the change in direction.
-/
def autoToMap (a : SymmBreak.Matrix.Auto m) (h : 2+m ≤ n) : AllVars n s → AllVars n s :=
  match a with
  | .renumber f =>
      AllVars.renumber fun j k =>
        if h' : 2 ≤ j.val ∧ j.val < 2+m then
          let x := (f ⟨j-2,by omega⟩).symm k
          if h'' : x < s then
            ⟨x,h''⟩
          else
            have : Inhabited (Fin s) := ⟨k⟩
            panic! "renumber maps outside s"
        else
          k
  | .reorder p =>
      AllVars.reorder <|
        Equiv.Perm.extendDomain (p := fun j => 2 ≤ j.val ∧ j.val < 2+m)
          p.symm
          { toFun := (⟨⟨·.val+2,by omega⟩,by simp; omega⟩)
            invFun := (⟨·.val-2,by omega⟩)
            left_inv := by intro; simp, right_inv := by rintro ⟨a,b⟩; ext; simp; omega
          }
  | .trans a1 a2 =>
      fun x => x |> autoToMap a2 h |> autoToMap a1 h
  | .lift a1 =>
      autoToMap a1 (Nat.le_of_lt h)

def mat_canonical (matSize : Nat) (h : 2 ≤ matSize ∧ matSize ≤ 3) : Array (Line n s) :=
  if h : ¬(2 + matSize ≤ n ∧ s ≥ n) then #[] else
  have := not_not.mp h

  Id.run do
  let mut lines := #[]

  have : NeZero s := ⟨by omega⟩

  for (x,v) in (canonicalMats.get matSize).map do
    match v with
    | .canon _ => pure ()
    | .noncanon canonical auto =>

      -- The clause we want to block (negation of `x`)
      let clause :=
        Array.finRange matSize |>.flatMap fun row => Array.ofFn (n := matSize) fun col =>
          Literal.neg <|
            AllVars.x (cX row.val) ⟨col+2, by omega⟩ (Fin.ofNat' s x.data[row][col])

      have : clause.size > 0 := by
        simp [clause, ← Array.sum_eq_sum_toList]; omega

      -- Assign all the literals associated with these rows/cols
      -- to their value under the canonical case
      let true_lits :=
        (List.ofFn (n := matSize) fun row =>
          List.ofFn (n := matSize) fun col =>
            List.ofFn (n := s) fun k =>
              Literal.mk
                (AllVars.x (cX row.val) ⟨col+2, by omega⟩ k)
                (k.val = canonical.data[row][col])
        ).flatten.flatten

      -- Permute all the other variables based on the given `auto`
      let subst := substsOfMap <| autoToMap auto (by omega)

      lines := lines.push <|
        mkLine clause ‹_› true_lits subst

  return lines

def all (n s) : Array (Line n s) := Id.run do
  let mut lines := #[]
  lines := lines ++ c3_bounds
  lines := lines ++ c3_fixed

  for hj : j in [2:n] do
    have : 2 ≤ j ∧ j < n := ⟨hj.lower,hj.upper⟩
    lines := lines ++ cX_bounds ⟨j,hj.upper⟩

    if h : j < 5 then
      lines := lines ++ col234_incSorted j (by omega)
    else
      lines := lines ++ col5_incSorted j (by omega)

    if h : 3 ≤ j ∧ j < 5 then
      lines := lines ++ mat_canonical (j-1) (by omega)
  return lines

end SR

namespace Cubes

open Vars

def matrixCubes (n s) : Cubing <| Literal (Vars n s) :=
  if h : n ≥ 5 ∧ s ≥ 4 then
    let matrixList := (SR.canonicalMats.get 3).canonical.toList
    let idxs := #[7, 11, 19]
    matrixList.map fun m =>
      Array.mk <| List.flatten <|
        List.ofFn fun r : Fin 3 => List.ofFn fun c : Fin 3 =>
          let mval : Fin s := @Fin.ofNat' s (by apply NeZero.mk; omega) m.data[r][c]
          .pos (x idxs[r] ⟨2+c, by omega⟩ mval)
  else
    .unit

def lastColsCubes (n s) : Cubing <| Literal (Vars n s) :=
  if h : s > 1 then
    let colorings := SR.col5_colorings s (by omega) |>.filterMap (·.getLeft?)
    let js := List.finRange n |>.filter (·.val ≥ 5)
    let cubes : List (Cubing _) := js.map fun j =>
      colorings.map fun coloring =>
        Array.ofFn (n := 4) fun idx =>
          .pos (x #v[3,7,11,19][idx] j coloring[idx])
    cubes.foldl (·.prod ·) (.unit)
  else .unit

def allCubes (n s) : List (Clause <| Literal <| Vars n s) :=
  let matCubes := matrixCubes n s
  let lastColsCubes := lastColsCubes n s

  let allCubes := matCubes.prod lastColsCubes

  allCubes.filter (·.size > 0)

end Cubes
