import verified_clique
import periodic_reduction

def is_s_discrete {d : ℕ} (s : ℕ) (T : set (point d)) : Prop :=
  ∀ i : fin d, ∃ coords : finset ℝ, coords.card ≤ s ∧ 
  (∀ coord1 ∈ coords, ∀ coord2 ∈ coords, coord1 ≠ coord2 → ne_mod_one coord1 coord2) ∧
  (∀ t ∈ T, ∃ coord ∈ coords, eq_mod_one (vector.nth t i) coord)

noncomputable def build_half_core_points_finset {d : ℕ} (i : fin d) (n : fin (d + 1)) :
  {s: finset ({p : point d // ∀ j : fin d, 
    (i = j → p.nth j = 0) ∧ (j.val < n.val → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ n.val → p.nth j = 0)}) //
  (i.val < n.val → s.card = 2^(n.val - 1)) ∧ (i.val ≥ n.val → s.card = 2^n.val) ∧ 
  ∀ p : point d, 
  ∀ h : (∀ j : fin d, (i = j → p.nth j = 0) ∧ (j.val < n.val → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ n.val → p.nth j = 0)),
  (⟨p, h⟩ : {p : point d // ∀ j : fin d, 
    (i = j → p.nth j = 0) ∧ (j.val < n.val → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ n.val → p.nth j = 0)}) ∈ s
  } :=
begin
  cases n with n_val n_property,
  simp only [fin.val_eq_coe, ge_iff_le],
  induction n_val with m ih,
  { norm_num,
    let res :
      finset ({p : point d // ∀ j : fin d, (i = j → p.nth j = 0) ∧ (j.val < 0 → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ 0 → p.nth j = 0)}) :=
      begin
        let zero_vector : 
          {p : point d // ∀ j : fin d, (i = j → p.nth j = 0) ∧ (j.val < 0 → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ 0 → p.nth j = 0)} :=
          begin
            let zero_vector : point d := vector.of_fn (λ i, 0),
            use zero_vector,
            intro j,
            split, {intro i_eq_j, dsimp[zero_vector], simp only [vector.nth_of_fn]},
            split, {intro i_lt_zero, exfalso, linarith},
            intro i_ge_zero,
            dsimp[zero_vector],
            simp only [vector.nth_of_fn],
          end,
        exact {zero_vector},
      end,
    use res,
    split, by {rw finset.card_eq_one, use (vector.of_fn (λ i, 0)),},
    intros p h,
    dsimp[res],
    simp only [finset.mem_singleton],
    apply vector.ext,
    intro j,
    replace h := h j,
    cases h with _ h,
    simp only [vector.nth_of_fn],
    exact h,
  },
  have m_lt_d_add_one : m < d + 1 := by omega,
  rcases ih m_lt_d_add_one with 
    ⟨core_points_finset_up_to_m, 
    ⟨core_points_finset_up_to_m_card_i_lt_m, core_points_finset_up_to_m_card_m_le_i, core_points_finset_up_to_m_property⟩⟩,
  let next_level_map : 
    {p : point d // ∀ (j : fin d), 
      (i = j → vector.nth p j = 0) ∧ (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0)} ↪ 
    {p : point d // ∀ (j : fin d), 
      (i = j → vector.nth p j = 0) ∧ (j.val < m.succ → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m.succ → vector.nth p j = 0)} := 
    begin
      let next_level_map_fn : 
        {p : point d // ∀ (j : fin d), 
          (i = j → vector.nth p j = 0) ∧ (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0)} → 
        {p : point d // ∀ (j : fin d), 
          (i = j → vector.nth p j = 0) ∧ (j.val < m.succ → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m.succ → vector.nth p j = 0)}
        := λ p, 
        begin
          use (vector.of_fn (λ j : fin d, if (i = j) then 0 else if (j.val = m) then p.val.nth j + 1 else p.val.nth j)),
          intro j,
          simp only [fin.val_eq_coe, ge_iff_le, vector.nth_of_fn, subtype.val_eq_coe],
          split, {intro i_eq_j, rw if_pos i_eq_j},
          by_cases i_eq_j : i = j,
          { rw if_pos i_eq_j,
            split, {intro _, left, refl},
            intro _, refl,
          },
          rename i_eq_j i_ne_j,
          rw if_neg i_ne_j,
          split,
          { intro j_lt_m_succ,
            by_cases j_eq_m : ↑j = m,
            { rw if_pos j_eq_m,
              right,
              have p_property := p.property j,
              rcases p_property with ⟨_, _, p_property⟩,
              simp only [ge_iff_le, subtype.val_eq_coe, j_eq_m] at p_property,
              rw [(p_property (by refl)), zero_add],
            },
            rename j_eq_m j_ne_m,
            rw if_neg j_ne_m,
            have p_property := p.property j,
            rcases p_property with ⟨_, p_property_j_lt_m, p_property_j_ge_m⟩,
            cases lt_or_ge j.val m with j_lt_m j_ge_m, exact p_property_j_lt_m j_lt_m,
            left,
            exact p_property_j_ge_m j_ge_m,
          },
          intro m_succ_le_j,
          have j_ne_m : ↑j ≠ m := by {clear_except m_succ_le_j, rw nat.succ_eq_add_one at m_succ_le_j, linarith},
          rw if_neg j_ne_m,
          have p_property := p.property j,
          rcases p_property with ⟨_, _, p_property_j_ge_m⟩,
          have j_ge_m : ↑j ≥ m := by {clear_except m_succ_le_j, rw nat.succ_eq_add_one at m_succ_le_j, linarith},
          simp only [subtype.val_eq_coe] at p_property_j_ge_m,
          exact p_property_j_ge_m j_ge_m,
        end,
      have next_level_map_fn_injective : function.injective next_level_map_fn :=
        begin
          rw function.injective,
          intros p1 p2 p1_output_eq_p2_output,
          apply subtype.ext,
          apply vector.ext,
          intro j,
          replace p1_output_eq_p2_output : (next_level_map_fn p1).val.nth j = (next_level_map_fn p2).val.nth j := 
            by rw p1_output_eq_p2_output,
          dsimp[next_level_map_fn] at p1_output_eq_p2_output,
          simp only [vector.nth_of_fn] at p1_output_eq_p2_output,
          by_cases i_eq_j : i = j,
          { have p1_property := p1.property j,
            have p2_property := p2.property j,
            rcases p1_property with ⟨p1_property, _, _⟩,
            rcases p2_property with ⟨p2_property, _, _⟩,
            simp only [subtype.val_eq_coe] at p1_property p2_property,
            rw [p1_property i_eq_j, p2_property i_eq_j],
          },
          rename i_eq_j i_ne_j,
          rw [if_neg i_ne_j, if_neg i_ne_j] at p1_output_eq_p2_output,
          by_cases j_eq_m : ↑j = m,
          { rw [if_pos j_eq_m, if_pos j_eq_m] at p1_output_eq_p2_output,
            clear_except p1_output_eq_p2_output,
            linarith,
          },
          rename j_eq_m j_ne_m,
          rw [if_neg j_ne_m, if_neg j_ne_m] at p1_output_eq_p2_output,
          exact p1_output_eq_p2_output,
        end,
      exact {to_fun := next_level_map_fn, inj' := next_level_map_fn_injective},
    end,
  let core_points_finset_up_to_m_mapped := finset.map next_level_map core_points_finset_up_to_m,
  have core_points_finset_up_to_m_mapped_card : core_points_finset_up_to_m_mapped.card = core_points_finset_up_to_m.card := 
    finset.card_map next_level_map,
  let cast_map :
    {p : point d // ∀ (j : fin d), 
      (i = j → vector.nth p j = 0) ∧ (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0)} ↪ 
    {p : point d // ∀ (j : fin d), 
      (i = j → vector.nth p j = 0) ∧ (j.val < m.succ → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m.succ → vector.nth p j = 0)} :=
    begin
      let cast_map_fn :
      {p : point d // ∀ (j : fin d), 
        (i = j → vector.nth p j = 0) ∧ (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0)} →
      {p : point d // ∀ (j : fin d), 
        (i = j → vector.nth p j = 0) ∧ (j.val < m.succ → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m.succ → vector.nth p j = 0)} 
        := λ p,
        begin
          use p.val,
          intro j,
          split,
          { intro i_eq_j,
            rw ← i_eq_j,
            have p_property := p.property i,
            rcases p_property with ⟨goal, _, _⟩,
            exact goal (by refl),
          },
          have p_property := p.property j,
          rcases p_property with ⟨_, p_property_j_lt_m, p_property_j_ge_m⟩,
          split,
          { intro j_lt_m_succ,
            by_cases j_lt_m : j.val < m, exact p_property_j_lt_m j_lt_m,
            rename j_lt_m j_ge_m,
            replace j_ge_m : j.val ≥ m := by {clear_except j_ge_m, linarith},
            left,
            exact p_property_j_ge_m j_ge_m,
          },
          intro j_ge_m_succ,
          have j_ge_m : j.val ≥ m := by {clear_except j_ge_m_succ, rw nat.succ_eq_add_one at j_ge_m_succ, linarith},
          exact p_property_j_ge_m j_ge_m,
        end,
      have cast_map_fn_injective : function.injective cast_map_fn :=
        begin
          rw function.injective,
          intros p1 p2 p1_output_eq_p2_output,
          dsimp[cast_map_fn] at p1_output_eq_p2_output,
          simp only at p1_output_eq_p2_output,
          refine subtype.eq _,
          simp only [subtype.val_eq_coe],
          exact p1_output_eq_p2_output,
        end,
      exact {to_fun := cast_map_fn, inj' := cast_map_fn_injective},
    end,
  let core_points_finset_up_to_m_cast := finset.map cast_map core_points_finset_up_to_m,
  have core_points_finset_up_to_m_cast_card : core_points_finset_up_to_m_cast.card = core_points_finset_up_to_m.card := 
    finset.card_map cast_map,
  by_cases i_eq_m : i.val = m,
  { use core_points_finset_up_to_m_cast,
    split,
    { intro i_lt_m_succ,
      have m_le_i : m ≤ ↑i := by {simp only [fin.val_eq_coe] at i_eq_m, rw i_eq_m},
      rw [core_points_finset_up_to_m_cast_card, core_points_finset_up_to_m_card_m_le_i m_le_i, nat.succ_eq_add_one],
      norm_num,
    },
    split,
    { intro i_ge_m_succ,
      exfalso,
      simp only [fin.val_eq_coe] at i_eq_m,
      clear_except i_ge_m_succ i_eq_m,
      rw [i_eq_m, nat.succ_eq_add_one] at i_ge_m_succ,
      linarith,
    },
    intros p h,
    have core_points_finset_up_to_m_property_precondition : ∀ (j : fin d), 
      (i = j → vector.nth p j = 0) ∧ (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0) :=
      begin
        intro j,
        replace h := h j,
        rcases h with ⟨h_i_eq_j, h_j_lt_m_succ, h_j_ge_m_succ⟩,
        split, exact h_i_eq_j,
        split,
        { intro j_lt_m,
          have j_lt_m_succ : j.val < m.succ := by {clear_except j_lt_m, rw nat.succ_eq_add_one, linarith},
          exact h_j_lt_m_succ j_lt_m_succ,
        },
        intro j_ge_m,
        by_cases j_eq_m : j.val = m,
        { have i_eq_j : i = j := by {apply subtype.ext, rw ← i_eq_m at j_eq_m, simp only [fin.val_eq_coe] at j_eq_m, symmetry, exact j_eq_m},
          exact h_i_eq_j i_eq_j,
        },
        rename j_eq_m j_ne_m,
        have j_ge_m_succ : j.val ≥ m.succ := by {clear_except j_ge_m j_ne_m, omega},
        exact h_j_ge_m_succ j_ge_m_succ,
      end,
    have p_in_core_points_finset_up_to_m := core_points_finset_up_to_m_property p core_points_finset_up_to_m_property_precondition,
    dsimp[core_points_finset_up_to_m_cast],
    simp only [exists_prop, add_zero, mul_one, gt_iff_lt, finset.mem_map, exists_and_distrib_right, int.coe_nat_add, ge_iff_le,
      int.coe_nat_one, exists_eq_right, function.embedding.coe_fn_mk, zero_add, subtype.exists, subtype.coe_mk, zero_lt_one,
      subtype.val_eq_coe, neg_zero],
    use core_points_finset_up_to_m_property_precondition,
    exact p_in_core_points_finset_up_to_m,
  },
  rename i_eq_m i_ne_m,
  have cast_disjoint_with_mapped : disjoint core_points_finset_up_to_m_cast core_points_finset_up_to_m_mapped :=
    begin
      rw disjoint,
      simp only [finset.inf_eq_inter, finset.bot_eq_empty, finset.le_eq_subset],
      intros shared_point shared_point_in_both,
      simp only [finset.not_mem_empty, finset.bot_eq_empty],
      simp only [le_refl, exists_prop, add_zero, mul_one, gt_iff_lt, fin.val_eq_coe, finset.mem_map, int.coe_nat_add, ge_iff_le,
        int.coe_nat_one, function.embedding.coe_fn_mk, vector.nth_of_fn, zero_add, neg_eq_zero, subtype.exists, neg_neg,
        subtype.coe_mk, zero_lt_one, finset.mem_inter, subtype.val_eq_coe, neg_zero] at shared_point_in_both,
      rcases shared_point_in_both with
        ⟨⟨shared_point_precast, shared_point_precast_property, shared_point_precast_in_core_points, shared_point_precast_eq_shared_point⟩, 
        ⟨shared_point_premap, shared_point_premap_property, shared_point_premap_in_core_points, shared_point_premap_eq_shared_point⟩⟩,
      have m_lt_d : m < d := by {clear_except n_property, rw nat.succ_eq_add_one at n_property, linarith},
      rcases shared_point_precast_property ⟨m, m_lt_d⟩ with ⟨_, _, h1⟩,
      rcases shared_point_premap_property ⟨m, m_lt_d⟩ with ⟨_, _, h2⟩,
      replace h1 := h1 rfl.ge,
      replace h2 := h2 rfl.ge,
      replace shared_point_precast_eq_shared_point : shared_point_precast = shared_point.val :=
        (congr_arg subtype.val shared_point_precast_eq_shared_point).congr_right.mp rfl,
      replace shared_point_premap_eq_shared_point : vector.of_fn 
        (λ (j : fin d), ite (i = j) 0 (ite (↑j = m) (vector.nth shared_point_premap j + 1) (vector.nth shared_point_premap j)))
        = shared_point.val := (congr_arg subtype.val shared_point_premap_eq_shared_point).congr_right.mp rfl,
      have shared_point_precast_eq_shared_point_at_m : shared_point_precast.nth ⟨m, m_lt_d⟩ = shared_point.val.nth ⟨m, m_lt_d⟩ :=
        by rw shared_point_precast_eq_shared_point,
      rw ← shared_point_premap_eq_shared_point at shared_point_precast_eq_shared_point_at_m,
      simp only [if_true, eq_self_iff_true, vector.nth_of_fn, fin.coe_mk] at shared_point_precast_eq_shared_point_at_m,
      have i_ne_m_as_fin : i ≠ ⟨m, m_lt_d⟩ := fin.ne_of_vne i_ne_m,
      rw [h1, h2, if_neg i_ne_m_as_fin] at shared_point_precast_eq_shared_point_at_m,
      norm_num at shared_point_precast_eq_shared_point_at_m,
    end,
  let res := core_points_finset_up_to_m_cast ∪ core_points_finset_up_to_m_mapped,
  have res_card_i_lt_m_succ : ↑i < m.succ → res.card = 2^m :=
    begin
      intro i_lt_m_succ,
      have i_lt_m : ↑i < m := by {clear_except i_ne_m i_lt_m_succ, simp only [fin.val_eq_coe] at i_ne_m, omega},
      dsimp[res],
      rw [finset.card_disjoint_union cast_disjoint_with_mapped, core_points_finset_up_to_m_cast_card,
        core_points_finset_up_to_m_mapped_card, core_points_finset_up_to_m_card_i_lt_m i_lt_m],
      have m_gt_zero : ∃ m' : ℕ, m = m'.succ :=
        begin
          have m_ne_zero : m ≠ 0 := by {clear_except i_lt_m, linarith},
          exact nat.exists_eq_succ_of_ne_zero m_ne_zero,
        end,
      cases m_gt_zero with m' m'_def,
      rw [m'_def, nat.succ_eq_add_one, pow_succ, two_mul],
      norm_num,
    end,
  have res_card_m_succ_le_i : m.succ ≤ ↑i → res.card = 2^m.succ :=
    begin
      intro m_succ_le_i,
      have m_le_i : m ≤ ↑i := by {clear_except m_succ_le_i, rw nat.succ_eq_add_one at m_succ_le_i, linarith},
      dsimp[res],
      rw [finset.card_disjoint_union cast_disjoint_with_mapped, core_points_finset_up_to_m_cast_card,
        core_points_finset_up_to_m_mapped_card, core_points_finset_up_to_m_card_m_le_i m_le_i, nat.succ_eq_add_one,
        pow_succ, two_mul],
    end,
  use res,
  split, {intro i_lt_m_succ, exact res_card_i_lt_m_succ i_lt_m_succ},
  split, {intro m_succ_le_i, exact res_card_m_succ_le_i m_succ_le_i},
  intros p h,
  have m_lt_d : m < d := by {clear_except n_property, omega},
  by_cases p_eq_zero_at_m : p.nth ⟨m, m_lt_d⟩ = 0,
  { have core_points_finset_up_to_m_property_precondition : ∀ (j : fin d), 
      (i = j → vector.nth p j = 0) ∧ (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0) :=
      begin
        intro j,
        rcases h j with ⟨h_i_eq_j, h_j_lt_m_succ, h_j_ge_m_succ⟩,
        split, exact h_i_eq_j,
        split,
        { intro j_lt_m,
          have j_lt_m_succ : j.val < m.succ := by {clear_except j_lt_m, rw nat.succ_eq_add_one, linarith},
          exact h_j_lt_m_succ j_lt_m_succ,
        },
        intro j_ge_m,
        by_cases j_eq_m : j = ⟨m, m_lt_d⟩,
        { rw ← j_eq_m at p_eq_zero_at_m,
          exact p_eq_zero_at_m,
        },
        rename j_eq_m j_ne_m,
        replace j_ne_m : j.val ≠ m :=
          begin
            simp only [fin.val_eq_coe],
            intro j_eq_m,
            conv at j_ne_m
            begin
              find m {rw ← j_eq_m},
            end,
            simp only [eq_self_iff_true, not_true, fin.eta] at j_ne_m,
            exact j_ne_m,
          end,
        have j_ge_m_succ : j.val ≥ m.succ := by {clear_except j_ge_m j_ne_m, omega},
        exact h_j_ge_m_succ j_ge_m_succ,
      end,
    have p_in_core_points_finset_up_to_m := core_points_finset_up_to_m_property p core_points_finset_up_to_m_property_precondition,
    dsimp only[res],
    apply finset.mem_union_left,
    dsimp only[core_points_finset_up_to_m_cast],
    simp only [exists_prop, fin.val_eq_coe, finset.mem_map, exists_and_distrib_right, ge_iff_le, exists_eq_right,
      function.embedding.coe_fn_mk, subtype.exists, subtype.coe_mk, subtype.val_eq_coe],
    use core_points_finset_up_to_m_property_precondition,
    exact p_in_core_points_finset_up_to_m,
  },
  rename p_eq_zero_at_m p_ne_zero_at_m,
  let premap_p : point d := vector.of_fn (λ j : fin d, if(i = j) then 0 else if(j.val = m) then 0 else p.nth j),
  have core_points_finset_up_to_m_property_precondition : ∀ (j : fin d), 
    (i = j → vector.nth premap_p j = 0) ∧ (j.val < m → vector.nth premap_p j = 0 ∨ vector.nth premap_p j = 1) ∧ 
    (j.val ≥ m → vector.nth premap_p j = 0) :=
    begin
      intro j,
      dsimp only[premap_p],
      simp only [fin.val_eq_coe, ge_iff_le, vector.nth_of_fn, ite_eq_left_iff],
      rcases h j with ⟨h_i_eq_j, h_j_lt_m_succ, h_j_ge_m_succ⟩,
      split,
      { intros i_eq_j i_ne_j,
        exfalso,
        exact i_ne_j i_eq_j,
      },
      split,
      { intro j_lt_m,
        by_cases i_eq_j : i = j,
        { left,
          intro i_ne_j,
          exfalso,
          exact i_ne_j i_eq_j,
        },
        rename i_eq_j i_ne_j,
        by_cases j_eq_m : ↑j = m,
        { left,
          intros i_ne_j j_ne_m,
          exfalso,
          exact j_ne_m j_eq_m,
        },
        rename j_eq_m j_ne_m,
        have j_lt_m_succ : j.val < m.succ := by {clear_except j_lt_m, rw nat.succ_eq_add_one, simp only [fin.val_eq_coe], linarith},
        cases h_j_lt_m_succ j_lt_m_succ with p_eq_zero p_eq_one,
        { left,
          intros i_ne_j j_ne_m,
          exact p_eq_zero,
        },
        right,
        rw [if_neg i_ne_j, if_neg j_ne_m],
        exact p_eq_one,
      },
      intros m_le_j i_ne_j j_ne_m,
      have j_ge_m : j.val ≥ m.succ := by {simp only [fin.val_eq_coe], clear_except m_le_j j_ne_m, omega},
      exact h_j_ge_m_succ j_ge_m,
    end,
  have premap_p_in_core_points_finset_up_to_m := 
    core_points_finset_up_to_m_property premap_p core_points_finset_up_to_m_property_precondition,
  dsimp only[res],
  apply finset.mem_union_right,
  dsimp only[core_points_finset_up_to_m_mapped],
  simp only [exists_prop, fin.val_eq_coe, finset.mem_map, exists_and_distrib_right, ge_iff_le, function.embedding.coe_fn_mk,
    subtype.exists, subtype.coe_mk, subtype.val_eq_coe],
  use premap_p,
  split,
  { use core_points_finset_up_to_m_property_precondition,
    exact premap_p_in_core_points_finset_up_to_m,
  },
  apply vector.ext,
  intro j,
  simp only [vector.nth_of_fn, subtype.val_eq_coe],
  rcases h j with ⟨h_i_eq_j, h_j_lt_m_succ, h_j_ge_m_succ⟩,
  by_cases i_eq_j : i = j,
  { rw if_pos i_eq_j,
    symmetry,
    exact h_i_eq_j i_eq_j,
  },
  rename i_eq_j i_ne_j,
  rw [if_neg i_ne_j, if_neg i_ne_j],
  by_cases j_eq_m : ↑j = m,
  { rw [if_pos j_eq_m, if_pos j_eq_m, zero_add],
    symmetry,
    have j_lt_m_succ : j.val < m.succ := by {simp only [fin.val_eq_coe], rw [j_eq_m, nat.succ_eq_add_one], norm_num},
    replace h_j_lt_m_succ := h_j_lt_m_succ j_lt_m_succ,
    cases h_j_lt_m_succ with p_eq_zero p_eq_one,
    { exfalso,
      have j_subst : j = ⟨m, m_lt_d⟩ := by {apply subtype.ext, rw j_eq_m, refl},
      rw ← j_subst at p_ne_zero_at_m,
      exact p_ne_zero_at_m p_eq_zero,
    },
    exact p_eq_one,
  },
  rename j_eq_m j_ne_m,
  rw [if_neg j_ne_m, if_neg j_ne_m],
end

noncomputable def build_core_points_finset {d : ℕ} (n : fin (d + 1)) :
  {s: finset ({p : point d // ∀ j : fin d, (j.val < n.val → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ n.val → p.nth j = 0)}) //
    s.card = 2^n.val ∧ 
    ∀ p : point d, ∀ h : (∀ j : fin d, (j.val < n.val → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ n.val → p.nth j = 0)),
    (⟨p, h⟩ : {p : point d // ∀ j : fin d, (j.val < n.val → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ n.val → p.nth j = 0)}) ∈ s
  } :=
begin
  cases n with n_val n_property,
  simp only [fin.val_eq_coe, ge_iff_le],
  induction n_val with m ih,
  { norm_num,
    let res : finset ({p : point d // ∀ j : fin d, (j.val < 0 → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ 0 → p.nth j = 0)}) :=
      begin
        let zero_vector : {p : point d // ∀ j : fin d, (j.val < 0 → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ 0 → p.nth j = 0)} :=
          begin
            let zero_vector : point d := vector.of_fn (λ i, 0),
            use zero_vector,
            intro j,
            split, {intro j_lt_zero, dsimp[zero_vector], simp only [or_false, vector.nth_of_fn, zero_ne_one]},
            intro j_ge_zero,
            dsimp[zero_vector],
            simp only [vector.nth_of_fn],
          end,
        exact {zero_vector},
      end,
    use res,
    split, by {rw finset.card_eq_one, use (vector.of_fn (λ i, 0)),},
    intros p h,
    dsimp[res],
    simp only [finset.mem_singleton],
    apply vector.ext,
    intro j,
    simp only [vector.nth_of_fn],
    exact h j,
  },
  have m_lt_d_add_one : m < d + 1 := by omega,
  rcases ih m_lt_d_add_one with 
    ⟨core_points_finset_up_to_m, ⟨core_points_finset_up_to_m_card, core_points_finset_up_to_m_property⟩⟩,
  let next_level_map : 
    {p : point d // ∀ (j : fin d), (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0)} ↪ 
    {p : point d // ∀ (j : fin d), (j.val < m.succ → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m.succ → vector.nth p j = 0)} :=
    begin
      let next_level_map_fn :
        {p : point d // ∀ (j : fin d), (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0)} →
        {p : point d // ∀ (j : fin d), (j.val < m.succ → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m.succ → vector.nth p j = 0)} := λ p,
        begin
          use (vector.of_fn (λ j, if (j.val = m) then p.val.nth j + 1 else p.val.nth j)),
          intro j,
          simp only [fin.val_eq_coe, ge_iff_le, vector.nth_of_fn, subtype.val_eq_coe],
          split,
          { intro j_lt_m_succ,
            by_cases j_eq_m : ↑j = m,
            { rw if_pos j_eq_m,
              right,
              have p_property := p.property j,
              rcases p_property with ⟨_, p_property⟩,
              simp only [ge_iff_le, subtype.val_eq_coe, j_eq_m] at p_property,
              rw [(p_property (by refl)), zero_add],
            },
            rename j_eq_m j_ne_m,
            rw if_neg j_ne_m,
            have p_property := p.property j,
            rcases p_property with ⟨p_property_j_lt_m, p_property_j_ge_m⟩,
            cases lt_or_ge j.val m with j_lt_m j_ge_m, exact p_property_j_lt_m j_lt_m,
            left,
            exact p_property_j_ge_m j_ge_m,
          },
          intro m_succ_le_j,
          have j_ne_m : ↑j ≠ m := by {clear_except m_succ_le_j, rw nat.succ_eq_add_one at m_succ_le_j, linarith},
          rw if_neg j_ne_m,
          have p_property := p.property j,
          rcases p_property with ⟨_, p_property_j_ge_m⟩,
          have j_ge_m : ↑j ≥ m := by {clear_except m_succ_le_j, rw nat.succ_eq_add_one at m_succ_le_j, linarith},
          simp only [subtype.val_eq_coe] at p_property_j_ge_m,
          exact p_property_j_ge_m j_ge_m,
        end,
      have next_level_map_fn_injective : function.injective next_level_map_fn :=
        begin
          rw function.injective,
          intros p1 p2 p1_output_eq_p2_output,
          apply subtype.ext,
          apply vector.ext,
          intro j,
          replace p1_output_eq_p2_output : (next_level_map_fn p1).val.nth j = (next_level_map_fn p2).val.nth j := 
            by rw p1_output_eq_p2_output,
          dsimp[next_level_map_fn] at p1_output_eq_p2_output,
          simp only [vector.nth_of_fn] at p1_output_eq_p2_output,
          by_cases j_eq_m : ↑j = m,
          { rw [if_pos j_eq_m, if_pos j_eq_m] at p1_output_eq_p2_output,
            clear_except p1_output_eq_p2_output,
            linarith,
          },
          rename j_eq_m j_ne_m,
          rw [if_neg j_ne_m, if_neg j_ne_m] at p1_output_eq_p2_output,
          exact p1_output_eq_p2_output,
        end,
      exact {to_fun := next_level_map_fn, inj' := next_level_map_fn_injective},
    end,
  let core_points_finset_up_to_m_mapped := finset.map next_level_map core_points_finset_up_to_m,
  have core_points_finset_up_to_m_mapped_card : core_points_finset_up_to_m_mapped.card = core_points_finset_up_to_m.card := 
    finset.card_map next_level_map,
  let cast_map :
    {p : point d // ∀ (j : fin d), (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0)} ↪ 
    {p : point d // ∀ (j : fin d), (j.val < m.succ → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m.succ → vector.nth p j = 0)} :=
    begin
      let cast_map_fn :
        {p : point d // ∀ (j : fin d), (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0)} →
        {p : point d // ∀ (j : fin d), (j.val < m.succ → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m.succ → vector.nth p j = 0)}
        := λ p,
        begin
          use p.val,
          intro j,
          have p_property := p.property j,
          rcases p_property with ⟨p_property_j_lt_m, p_property_j_ge_m⟩,
          split,
          { intro j_lt_m_succ,
            by_cases j_lt_m : j.val < m, exact p_property_j_lt_m j_lt_m,
            rename j_lt_m j_ge_m,
            replace j_ge_m : j.val ≥ m := by {clear_except j_ge_m, linarith},
            left,
            exact p_property_j_ge_m j_ge_m,
          },
          intro j_ge_m_succ,
          have j_ge_m : j.val ≥ m := by {clear_except j_ge_m_succ, rw nat.succ_eq_add_one at j_ge_m_succ, linarith},
          exact p_property_j_ge_m j_ge_m,
        end,
      have cast_map_fn_injective : function.injective cast_map_fn :=
        begin
          rw function.injective,
          intros p1 p2 p1_output_eq_p2_output,
          dsimp[cast_map_fn] at p1_output_eq_p2_output,
          simp only at p1_output_eq_p2_output,
          refine subtype.eq _,
          simp only [subtype.val_eq_coe],
          exact p1_output_eq_p2_output,
        end,
      exact {to_fun := cast_map_fn, inj' := cast_map_fn_injective},
    end,
  let core_points_finset_up_to_m_cast := finset.map cast_map core_points_finset_up_to_m,
  have core_points_finset_up_to_m_cast_card : core_points_finset_up_to_m_cast.card = core_points_finset_up_to_m.card := 
    finset.card_map cast_map,
  have cast_disjoint_with_mapped : disjoint core_points_finset_up_to_m_cast core_points_finset_up_to_m_mapped :=
    begin
      rw disjoint,
      simp only [finset.inf_eq_inter, finset.bot_eq_empty, finset.le_eq_subset],
      intros shared_point shared_point_in_both,
      simp only [finset.not_mem_empty, finset.bot_eq_empty],
      simp only [le_refl, exists_prop, add_zero, mul_one, gt_iff_lt, fin.val_eq_coe, finset.mem_map, int.coe_nat_add, ge_iff_le,
        int.coe_nat_one, function.embedding.coe_fn_mk, vector.nth_of_fn, zero_add, neg_eq_zero, subtype.exists, neg_neg,
        subtype.coe_mk, zero_lt_one, finset.mem_inter, subtype.val_eq_coe, neg_zero] at shared_point_in_both,
      rcases shared_point_in_both with
        ⟨⟨shared_point_precast, shared_point_precast_property, shared_point_precast_in_core_points, shared_point_precast_eq_shared_point⟩, 
        ⟨shared_point_premap, shared_point_premap_property, shared_point_premap_in_core_points, shared_point_premap_eq_shared_point⟩⟩,
      have m_lt_d : m < d := by {clear_except n_property, rw nat.succ_eq_add_one at n_property, linarith},
      rcases shared_point_precast_property ⟨m, m_lt_d⟩ with ⟨_, h1⟩,
      rcases shared_point_premap_property ⟨m, m_lt_d⟩ with ⟨_, h2⟩,
      replace h1 := h1 rfl.ge,
      replace h2 := h2 rfl.ge,
      replace shared_point_precast_eq_shared_point : shared_point_precast = shared_point.val :=
        (congr_arg subtype.val shared_point_precast_eq_shared_point).congr_right.mp rfl,
      replace shared_point_premap_eq_shared_point : vector.of_fn
        (λ (j : fin d), ite (↑j = m) (vector.nth shared_point_premap j + 1) (vector.nth shared_point_premap j))
        = shared_point.val := (congr_arg subtype.val shared_point_premap_eq_shared_point).congr_right.mp rfl,
      have shared_point_precast_eq_shared_point_at_m : shared_point_precast.nth ⟨m, m_lt_d⟩ = shared_point.val.nth ⟨m, m_lt_d⟩ :=
        by rw shared_point_precast_eq_shared_point,
      rw ← shared_point_premap_eq_shared_point at shared_point_precast_eq_shared_point_at_m,
      simp only [if_true, eq_self_iff_true, vector.nth_of_fn, fin.coe_mk] at shared_point_precast_eq_shared_point_at_m,
      rw [h1, h2] at shared_point_precast_eq_shared_point_at_m,
      norm_num at shared_point_precast_eq_shared_point_at_m,
    end,
  let res := core_points_finset_up_to_m_cast ∪ core_points_finset_up_to_m_mapped,
  have res_card : res.card = 2^m.succ :=
    begin
      dsimp[res],
      rw [finset.card_disjoint_union cast_disjoint_with_mapped, core_points_finset_up_to_m_cast_card,
        core_points_finset_up_to_m_mapped_card, core_points_finset_up_to_m_card],
      rw [nat.succ_eq_add_one, pow_succ, two_mul],
    end,
  use [res, res_card],
  intros p h,
  have m_lt_d : m < d := by {clear_except n_property, omega},
  by_cases p_eq_zero_at_m : p.nth ⟨m, m_lt_d⟩ = 0,
  { have core_points_finset_up_to_m_property_precondition : ∀ (j : fin d), 
      (j.val < m → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ m → vector.nth p j = 0) :=
      begin
        intro j,
        rcases h j with ⟨h_j_lt_m_succ, h_j_ge_m_succ⟩,
        split,
        { intro j_lt_m,
          have j_lt_m_succ : j.val < m.succ := by {clear_except j_lt_m, rw nat.succ_eq_add_one, linarith},
          exact h_j_lt_m_succ j_lt_m_succ,
        },
        intro j_ge_m,
        by_cases j_eq_m : j = ⟨m, m_lt_d⟩,
        { rw ← j_eq_m at p_eq_zero_at_m,
          exact p_eq_zero_at_m,
        },
        rename j_eq_m j_ne_m,
        replace j_ne_m : j.val ≠ m :=
          begin
            simp only [fin.val_eq_coe],
            intro j_eq_m,
            conv at j_ne_m
            begin
              find m {rw ← j_eq_m},
            end,
            simp only [eq_self_iff_true, not_true, fin.eta] at j_ne_m,
            exact j_ne_m,
          end,
        have j_ge_m_succ : j.val ≥ m.succ := by {clear_except j_ge_m j_ne_m, omega},
        exact h_j_ge_m_succ j_ge_m_succ,
      end,
    have p_in_core_points_finset_up_to_m := core_points_finset_up_to_m_property p core_points_finset_up_to_m_property_precondition,
    dsimp only[res],
    apply finset.mem_union_left,
    dsimp only[core_points_finset_up_to_m_cast],
    simp only [exists_prop, fin.val_eq_coe, finset.mem_map, exists_and_distrib_right, ge_iff_le, exists_eq_right,
      function.embedding.coe_fn_mk, subtype.exists, subtype.coe_mk, subtype.val_eq_coe],
    use core_points_finset_up_to_m_property_precondition,
    exact p_in_core_points_finset_up_to_m,
  },
  rename p_eq_zero_at_m p_ne_zero_at_m,
  let premap_p : point d := vector.of_fn (λ j : fin d, if(j.val = m) then 0 else p.nth j),
  have core_points_finset_up_to_m_property_precondition : ∀ (j : fin d), 
    (j.val < m → vector.nth premap_p j = 0 ∨ vector.nth premap_p j = 1) ∧ (j.val ≥ m → vector.nth premap_p j = 0) :=
    begin
      intro j,
      dsimp only[premap_p],
      simp only [fin.val_eq_coe, ge_iff_le, vector.nth_of_fn, ite_eq_left_iff],
      rcases h j with ⟨h_j_lt_m_succ, h_j_ge_m_succ⟩,
      split,
      { intro j_lt_m,
        by_cases j_eq_m : ↑j = m,
        { left,
          intro j_ne_m,
          exfalso,
          exact j_ne_m j_eq_m,
        },
        rename j_eq_m j_ne_m,
        have j_lt_m_succ : j.val < m.succ := by {clear_except j_lt_m, rw nat.succ_eq_add_one, simp only [fin.val_eq_coe], linarith},
        cases h_j_lt_m_succ j_lt_m_succ with p_eq_zero p_eq_one,
        { left,
          intro j_ne_m,
          exact p_eq_zero,
        },
        right,
        rw if_neg j_ne_m,
        exact p_eq_one,
      },
      intros m_le_j j_ne_m,
      have j_ge_m : j.val ≥ m.succ := by {simp only [fin.val_eq_coe], clear_except m_le_j j_ne_m, omega},
      exact h_j_ge_m_succ j_ge_m,
    end,
  have premap_p_in_core_points_finset_up_to_m := 
    core_points_finset_up_to_m_property premap_p core_points_finset_up_to_m_property_precondition,
  dsimp only[res],
  apply finset.mem_union_right,
  dsimp only[core_points_finset_up_to_m_mapped],
  simp only [exists_prop, fin.val_eq_coe, finset.mem_map, exists_and_distrib_right, ge_iff_le, function.embedding.coe_fn_mk,
    subtype.exists, subtype.coe_mk, subtype.val_eq_coe],
  use premap_p,
  split,
  { use core_points_finset_up_to_m_property_precondition,
    exact premap_p_in_core_points_finset_up_to_m,
  },
  apply vector.ext,
  intro j,
  simp only [vector.nth_of_fn, subtype.val_eq_coe],
  rcases h j with ⟨h_j_lt_m_succ, h_j_ge_m_succ⟩,
  by_cases j_eq_m : ↑j = m,
  { rw [if_pos j_eq_m, if_pos j_eq_m, zero_add],
    symmetry,
    have j_lt_m_succ : j.val < m.succ := by {simp only [fin.val_eq_coe], rw [j_eq_m, nat.succ_eq_add_one], norm_num},
    replace h_j_lt_m_succ := h_j_lt_m_succ j_lt_m_succ,
    cases h_j_lt_m_succ with p_eq_zero p_eq_one,
    { exfalso,
      have j_subst : j = ⟨m, m_lt_d⟩ := by {apply subtype.ext, rw j_eq_m, refl},
      rw ← j_subst at p_ne_zero_at_m,
      exact p_ne_zero_at_m p_eq_zero,
    },
    exact p_eq_one,
  },
  rename j_eq_m j_ne_m,
  rw [if_neg j_ne_m, if_neg j_ne_m],
end

theorem s_discrete_upper_bound :
  ∀ d : ℕ, ∀ T : set (point d), ∀ T_is_tiling : is_tiling T,
  d > 0 → is_periodic T_is_tiling → is_s_discrete (2^(d-1)) T :=
begin
  intros d T T_is_tiling d_gt_zero T_is_periodic,
  rw is_s_discrete,
  intro i,
  have core_points_finset := build_half_core_points_finset i ⟨d, lt_add_one d⟩,
  rcases core_points_finset with ⟨core_points_finset, core_points_finset_card, vacuous, core_points_finset_property⟩,
  clear vacuous, --vacuous was useful inductively for build_half_core_points_finset, always has a false hypothesis here because i : fin d
  simp only at core_points_finset_card,
  replace core_points_finset_card := core_points_finset_card i.property,
  let T_core_map :
    {p : point d // ∀ (j : fin d), 
      (i = j → vector.nth p j = 0) ∧ (j.val < d → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ d → vector.nth p j = 0)} ↪
    {p_corner : point d // p_corner ∈ T ∧ ∃ p : point d, in_cube p_corner p ∧ ∀ (j : fin d),
      (i = j → vector.nth p j = 0) ∧ (j.val < d → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ d → vector.nth p j = 0)} :=
    begin
      let T_core_map_fn :
        {p : point d // ∀ (j : fin d), 
          (i = j → vector.nth p j = 0) ∧ (j.val < d → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ d → vector.nth p j = 0)} →
        {p_corner : point d // p_corner ∈ T ∧ ∃ p : point d, in_cube p_corner p ∧ ∀ (j : fin d),
          (i = j → vector.nth p j = 0) ∧ (j.val < d → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ d → vector.nth p j = 0)}
        := λ p,
        begin
          use (point_to_corner T_is_tiling p).val,
          let p_corner := (point_to_corner T_is_tiling p).val,
          have p_corner_def : p_corner = (point_to_corner T_is_tiling p).val := by refl,
          have p_corner_property := (point_to_corner T_is_tiling p).property,
          rw ← p_corner_def at p_corner_property,
          rcases p_corner_property with ⟨p_corner_in_T, p_in_p_corner, p_corner_unique⟩,
          rw cube at p_in_p_corner,
          simp only [set.mem_set_of_eq] at p_in_p_corner,
          split, exact p_corner_in_T,
          use p,
          split, exact p_in_p_corner,
          intro j,
          have p_property := p.property j,
          simp only [subtype.val_eq_coe] at p_property,
          simp only [subtype.val_eq_coe],
          exact p_property,
        end,
      have T_core_map_fn_injective : function.injective T_core_map_fn :=
        begin
          intros p1 p2 p1_output_eq_p2_output,
          dsimp[T_core_map_fn] at p1_output_eq_p2_output,
          simp only at p1_output_eq_p2_output,
          apply subtype.ext,
          apply vector.ext,
          intro j,
          have p1_property := p1.property j,
          have p2_property := p2.property j,
          rcases p1_property with ⟨unneeded, p1_property, vacuous⟩,
          clear vacuous unneeded,
          rcases p2_property with ⟨unneeded, p2_property, vacuous⟩,
          clear vacuous unneeded,
          replace p1_property := p1_property j.property,
          replace p2_property := p2_property j.property,
          have p1_corner_property := (point_to_corner T_is_tiling ↑p1).property,
          simp only [subtype.val_eq_coe] at p1_corner_property,
          rcases p1_corner_property with ⟨p1_corner_in_T, p1_in_p1_corner, p1_corner_unique⟩,
          have p2_corner_property := (point_to_corner T_is_tiling ↑p2).property,
          simp only [subtype.val_eq_coe] at p2_corner_property,
          rcases p2_corner_property with ⟨p2_corner_in_T, p2_in_p2_corner, p2_corner_unique⟩,
          simp only [subtype.val_eq_coe] at p1_property p2_property,
          cases p1_property with p1_eq_zero p1_eq_one,
          { cases p2_property with p2_eq_zero p2_eq_one, rw [p1_eq_zero, p2_eq_zero],
            rw cube at p1_in_p1_corner p2_in_p2_corner,
            simp only [set.mem_set_of_eq] at p1_in_p1_corner p2_in_p2_corner,
            rw in_cube at p1_in_p1_corner p2_in_p2_corner,
            replace p1_in_p1_corner := p1_in_p1_corner j,
            replace p2_in_p2_corner := p2_in_p2_corner j,
            rw p2_eq_one at p2_in_p2_corner,
            rw [p1_eq_zero, p1_output_eq_p2_output] at p1_in_p1_corner,
            exfalso,
            clear_except p1_in_p1_corner p2_in_p2_corner,
            linarith,
          },
          cases p2_property with p2_eq_zero p2_eq_one,
          { rw cube at p1_in_p1_corner p2_in_p2_corner,
            simp only [set.mem_set_of_eq] at p1_in_p1_corner p2_in_p2_corner,
            rw in_cube at p1_in_p1_corner p2_in_p2_corner,
            replace p1_in_p1_corner := p1_in_p1_corner j,
            replace p2_in_p2_corner := p2_in_p2_corner j,
            rw p2_eq_zero at p2_in_p2_corner,
            rw [p1_eq_one, p1_output_eq_p2_output] at p1_in_p1_corner,
            exfalso,
            clear_except p1_in_p1_corner p2_in_p2_corner,
            linarith,
          },
          rw [p1_eq_one, p2_eq_one],
        end,
      exact {to_fun := T_core_map_fn, inj' := T_core_map_fn_injective},
    end,
  let T_core := finset.map T_core_map core_points_finset,
  have T_core_card : T_core.card = core_points_finset.card := finset.card_map T_core_map,
  rw core_points_finset_card at T_core_card,
  let T_core_list := finset.to_list T_core,
  let T_core_point_to_i_coord_fn :=
    (λ corner : {p_corner // p_corner ∈ T ∧ ∃ (p : point d), in_cube p_corner p ∧ ∀ (j : fin d),(i = j → vector.nth p j = 0) ∧
                  (j.val < d → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (j.val ≥ d → vector.nth p j = 0)}, 
      corner.val.nth i
    ),
  let coords_list := list.map T_core_point_to_i_coord_fn T_core_list,
  have T_core_list_length : T_core_list.length = T_core.card := finset.length_to_list T_core,
  have coords_list_length : coords_list.length = T_core_list.length := list.length_map T_core_point_to_i_coord_fn T_core_list,
  let coords := coords_list.to_finset,
  have coords_card : coords.card ≤ coords_list.length := list.to_finset_card_le coords_list,
  rw [coords_list_length, T_core_list_length, T_core_card] at coords_card,
  use coords,
  split, exact coords_card,
  split,
  { --Derive contradiction between coord1_eq_coord2_mod_one and coord1_ne_coord2
    intros coord1 coord1_in_coords coord2 coord2_in_coords coord1_ne_coord2 coord1_eq_coord2_mod_one,
    have coord1_in_coords_list := by {rw list.mem_to_finset at coord1_in_coords, exact coord1_in_coords},
    have coord2_in_coords_list := by {rw list.mem_to_finset at coord2_in_coords, exact coord2_in_coords},
    dsimp[coords_list, T_core_point_to_i_coord_fn] at coord1_in_coords_list coord2_in_coords_list,
    simp only [not_exists, exists_prop, add_zero, list.mem_map, fin.val_eq_coe, finset.mem_map, ge_iff_le, finset.mem_to_list,
      subtype.mk_eq_mk, function.embedding.coe_fn_mk, zero_add, subtype.exists, set.mem_set_of_eq, subtype.coe_mk,
      subtype.val_eq_coe, list.map] at coord1_in_coords_list coord2_in_coords_list,
    rcases coord1_in_coords_list with
      ⟨p1, ⟨p1_in_T, ⟨p1_core_point, p1_core_point_in_p1, p1_core_point_property⟩⟩, redundant, coord1_eq_p1_at_i⟩,
    clear redundant,
    rcases coord2_in_coords_list with
      ⟨p2, ⟨p2_in_T, ⟨p2_core_point, p2_core_point_in_p2, p2_core_point_property⟩⟩, redundant, coord2_eq_p2_at_i⟩,
    clear redundant,
    rcases p1_core_point_property i with ⟨p1_core_point_eq_zero_at_i, unneeded⟩,
    clear unneeded,
    rcases p2_core_point_property i with ⟨p2_core_point_eq_zero_at_i, unneeded⟩,
    clear unneeded,
    replace p1_core_point_eq_zero_at_i := p1_core_point_eq_zero_at_i (by refl),
    replace p2_core_point_eq_zero_at_i := p2_core_point_eq_zero_at_i (by refl),
    rw in_cube at p1_core_point_in_p1 p2_core_point_in_p2,
    replace p1_core_point_in_p1 := p1_core_point_in_p1 i,
    replace p2_core_point_in_p2 := p2_core_point_in_p2 i,
    rcases p1_core_point_in_p1 with ⟨p1_le_p1_core_point, p1_core_point_lt_p1_add_1⟩,
    rcases p2_core_point_in_p2 with ⟨p2_le_p2_core_point, p2_core_point_lt_p2_add_2⟩,
    rcases coord1_eq_coord2_mod_one with 
      ⟨coord1_floor, coord2_floor, y, zero_le_y, y_lt_one, coord1_eq_coord1_floor_add_y, coord2_eq_coord2_floor_add_y⟩,
    have coord1_floor_eq_coord2_floor : coord1_floor = coord2_floor :=
      begin
        rw [p1_core_point_eq_zero_at_i, coord1_eq_p1_at_i] at p1_le_p1_core_point p1_core_point_lt_p1_add_1,
        rw [p2_core_point_eq_zero_at_i, coord2_eq_p2_at_i] at p2_le_p2_core_point p2_core_point_lt_p2_add_2,
        by_contra coord1_floor_ne_coord2_floor,
        cases lt_or_gt_of_ne coord1_floor_ne_coord2_floor with coord1_floor_lt_coord2_floor coord1_floor_gt_coord2_floor,
        { have coord1_floor_le_coord2_floor_add_one : coord1_floor ≤ coord2_floor + 1 :=
            by {clear_except coord1_floor_lt_coord2_floor, omega},
          by_cases y_eq_zero : y = 0,
          { rw [y_eq_zero, add_zero] at coord1_eq_coord1_floor_add_y coord2_eq_coord2_floor_add_y,
            rcases real_eq_or_lt_or_gt coord1 0 with coord1_eq_zero | coord1_lt_zero | coord1_gt_zero,
            { have neg_one_lt_coord2 : -1 < coord2 := by {clear_except p2_core_point_lt_p2_add_2, linarith},
              have zero_le_coord2 : 0 ≤ coord2 :=
                begin
                  have neg_one_lt_coord2_floor : -1 < coord2_floor :=
                    by {rw coord2_eq_coord2_floor_add_y at neg_one_lt_coord2, exact_mod_cast neg_one_lt_coord2},
                  have h := int.add_one_le_of_lt neg_one_lt_coord2_floor,
                  simp only [add_left_neg] at h,
                  rw coord2_eq_coord2_floor_add_y,
                  exact_mod_cast h,
                end,
              have coord2_eq_zero : coord2 = 0 := by {clear_except p2_le_p2_core_point zero_le_coord2, linarith},
              rw ← coord1_eq_zero at coord2_eq_zero,
              symmetry' at coord2_eq_zero,
              exact coord1_ne_coord2 coord2_eq_zero,
            },
            { have neg_one_lt_coord1_floor : -1 < coord1_floor :=
                begin
                  have neg_one_lt_coord1 : -1 < coord1 := by {clear_except p1_core_point_lt_p1_add_1, linarith},
                  rw coord1_eq_coord1_floor_add_y at neg_one_lt_coord1,
                  exact_mod_cast neg_one_lt_coord1,
                end,
              have coord1_floor_lt_zero : coord1_floor < 0 :=
                by {rw coord1_eq_coord1_floor_add_y at coord1_lt_zero, exact_mod_cast coord1_lt_zero},
              clear_except neg_one_lt_coord1_floor coord1_floor_lt_zero,
              omega,
            },
            clear_except coord1_gt_zero p1_le_p1_core_point,
            linarith,
          },
          rename y_eq_zero y_ne_zero,
          rcases lt_or_gt_of_ne y_ne_zero with y_lt_zero | y_gt_zero,
          { clear_except zero_le_y y_lt_zero,
            linarith,
          },
          rcases eq_or_lt_or_gt coord1_floor (-1) with coord1_floor_eq_neg_one | coord1_floor_lt_neg_one | coord1_floor_gt_neg_one,
          { have zero_le_coord2_floor : 0 ≤ coord2_floor :=
              begin
                rw coord1_floor_eq_neg_one at coord1_floor_lt_coord2_floor,
                clear_except coord1_floor_lt_coord2_floor,
                omega,
              end,
            have zero_le_cast_coord2_floor : (0 : ℝ) ≤ ↑coord2_floor := by {exact_mod_cast zero_le_coord2_floor},
            clear_except zero_le_cast_coord2_floor coord2_eq_coord2_floor_add_y y_gt_zero p2_le_p2_core_point,
            linarith,
          },
          { have coord1_floor_le_neg_two : coord1_floor ≤ -2 := by {clear_except coord1_floor_lt_neg_one, omega},
            have cast_coord1_floor_le_neg_two : ↑coord1_floor ≤ (-2 : ℝ) := by {exact_mod_cast coord1_floor_le_neg_two},
            rw coord1_eq_coord1_floor_add_y at p1_core_point_lt_p1_add_1,
            clear_except p1_core_point_lt_p1_add_1 y_lt_one cast_coord1_floor_le_neg_two,
            linarith,
          },
          have coord1_floor_ge_zero : coord1_floor ≥ 0 := by {clear_except coord1_floor_gt_neg_one, omega},
          have cast_coord1_floor_ge_zero : ↑coord1_floor ≥ (0 : ℝ) := by {exact_mod_cast coord1_floor_ge_zero},
          rw coord1_eq_coord1_floor_add_y at p1_le_p1_core_point,
          clear_except p1_le_p1_core_point y_gt_zero cast_coord1_floor_ge_zero,
          linarith,
        },
        --Symmetric to above case
        have coord2_floor_le_coord1_floor_add_one : coord2_floor ≤ coord1_floor + 1 :=
          by {clear_except coord1_floor_gt_coord2_floor, omega},
        by_cases y_eq_zero : y = 0,
        { rw [y_eq_zero, add_zero] at coord1_eq_coord1_floor_add_y coord2_eq_coord2_floor_add_y,
          rcases real_eq_or_lt_or_gt coord2 0 with coord2_eq_zero | coord2_lt_zero | coord2_gt_zero,
          { have neg_one_lt_coord1 : -1 < coord1 := by {clear_except p1_core_point_lt_p1_add_1, linarith},
            have zero_le_coord1 : 0 ≤ coord1 :=
              begin
                have neg_one_lt_coord1_floor : -1 < coord1_floor :=
                  by {rw coord1_eq_coord1_floor_add_y at neg_one_lt_coord1, exact_mod_cast neg_one_lt_coord1},
                have h := int.add_one_le_of_lt neg_one_lt_coord1_floor,
                simp only [add_left_neg] at h,
                rw coord1_eq_coord1_floor_add_y,
                exact_mod_cast h,
              end,
            have coord1_eq_zero : coord1 = 0 := by {clear_except p1_le_p1_core_point zero_le_coord1, linarith},
            rw ← coord2_eq_zero at coord1_eq_zero,
            exact coord1_ne_coord2 coord1_eq_zero,
          },
          { have neg_one_lt_coord2_floor : -1 < coord2_floor :=
              begin
                have neg_one_lt_coord2 : -1 < coord2 := by {clear_except p2_core_point_lt_p2_add_2, linarith},
                rw coord2_eq_coord2_floor_add_y at neg_one_lt_coord2,
                exact_mod_cast neg_one_lt_coord2,
              end,
            have coord2_floor_lt_zero : coord2_floor < 0 :=
              by {rw coord2_eq_coord2_floor_add_y at coord2_lt_zero, exact_mod_cast coord2_lt_zero},
            clear_except neg_one_lt_coord2_floor coord2_floor_lt_zero,
            omega,
          },
          clear_except coord2_gt_zero p2_le_p2_core_point,
          linarith,
        },
        rename y_eq_zero y_ne_zero,
        rcases lt_or_gt_of_ne y_ne_zero with y_lt_zero | y_gt_zero,
        { clear_except zero_le_y y_lt_zero,
          linarith,
        },
        rcases eq_or_lt_or_gt coord2_floor (-1) with coord2_floor_eq_neg_one | coord2_floor_lt_neg_one | coord2_floor_gt_neg_one,
        { have zero_le_coord1_floor : 0 ≤ coord1_floor :=
            begin
              rw coord2_floor_eq_neg_one at coord1_floor_gt_coord2_floor,
              clear_except coord1_floor_gt_coord2_floor,
              omega,
            end,
          have zero_le_cast_coord1_floor : (0 : ℝ) ≤ ↑coord1_floor := by {exact_mod_cast zero_le_coord1_floor},
          clear_except zero_le_cast_coord1_floor coord1_eq_coord1_floor_add_y y_gt_zero p1_le_p1_core_point,
          linarith,
        },
        { have coord2_floor_le_neg_two : coord2_floor ≤ -2 := by {clear_except coord2_floor_lt_neg_one, omega},
          have cast_coord2_floor_le_neg_two : ↑coord2_floor ≤ (-2 : ℝ) := by {exact_mod_cast coord2_floor_le_neg_two},
          rw coord2_eq_coord2_floor_add_y at p2_core_point_lt_p2_add_2,
          clear_except p2_core_point_lt_p2_add_2 y_lt_one cast_coord2_floor_le_neg_two,
          linarith,
        },
        have coord2_floor_ge_zero : coord2_floor ≥ 0 := by {clear_except coord2_floor_gt_neg_one, omega},
        have cast_coord2_floor_ge_zero : ↑coord2_floor ≥ (0 : ℝ) := by {exact_mod_cast coord2_floor_ge_zero},
        rw coord2_eq_coord2_floor_add_y at p2_le_p2_core_point,
        clear_except p2_le_p2_core_point y_gt_zero cast_coord2_floor_ge_zero,
        linarith,
      end,
    rw [coord1_floor_eq_coord2_floor, ← coord2_eq_coord2_floor_add_y] at coord1_eq_coord1_floor_add_y,
    exact coord1_ne_coord2 coord1_eq_coord1_floor_add_y,
  },
  intros t t_in_T,
  have t_has_periodic_core := (has_periodic_core_of_is_periodic d T T_is_tiling T_is_periodic) t t_in_T,
  rcases t_has_periodic_core with ⟨p, p_in_core_points, t_core, t_core_in_T, t_offset, p_in_t_core, t_def⟩,
  by_cases p_eq_zero_at_i : p.nth i = 0,
  { have p_has_core_points_finset_property : 
      ∀ j : fin d, (i = j → p.nth j = 0) ∧ (j.val < d → p.nth j = 0 ∨ p.nth j = 1) ∧ (j.val ≥ d → p.nth j = 0) :=
      begin
        intro j,
        replace p_in_core_points := p_in_core_points j,
        split, {intro i_eq_j, rw ← i_eq_j, exact p_eq_zero_at_i},
        split, {intro j_lt_d, exact p_in_core_points},
        intro j_ge_d,
        exfalso,
        have j_lt_d := j.property,
        clear_except j_ge_d j_lt_d,
        linarith,
      end,
    have p_in_core_points_finset := core_points_finset_property p p_has_core_points_finset_property,
    have t_core_has_T_core_map_property : t_core ∈ T ∧ ∃ p : point d, in_cube t_core p ∧ 
      ∀ (j : fin d), (i = j → vector.nth p j = 0) ∧ (↑j < d → vector.nth p j = 0 ∨ vector.nth p j = 1) ∧ (↑j ≥ d → vector.nth p j = 0)
      := ⟨t_core_in_T, Exists.intro p ⟨p_in_t_core, p_has_core_points_finset_property⟩⟩,
    have t_core_eq_p_corner : t_core = ↑(point_to_corner T_is_tiling p) :=
      begin
        have p_corner_property := (point_to_corner T_is_tiling p).property,
        simp only [subtype.val_eq_coe] at p_corner_property,
        rcases p_corner_property with ⟨p_corner_in_T, p_in_p_corner, p_corner_unique⟩,
        replace p_in_t_core : p ∈ cube t_core := by {rw cube, simp only [set.mem_set_of_eq], exact p_in_t_core},
        exact p_corner_unique t_core t_core_in_T p_in_t_core,
      end,
    let p_corner_coord := T_core_point_to_i_coord_fn (T_core_map ⟨p, p_has_core_points_finset_property⟩),
    have p_corner_coord_in_coords : p_corner_coord ∈ coords :=
      begin
        dsimp[coords, coords_list, T_core_list, T_core],
        simp only [exists_prop, list.mem_map, finset.mem_map, list.mem_to_finset, ge_iff_le, finset.mem_to_list, subtype.exists,
          list.map],
        use [t_core, t_core_has_T_core_map_property],
        split,
        { use [p, p_has_core_points_finset_property],
          split, exact p_in_core_points_finset,
          dsimp[T_core_map],
          apply subtype.ext,
          simp only [subtype.coe_mk],
          symmetry,
          exact t_core_eq_p_corner,
        },
        dsimp[p_corner_coord],
        conv
        begin
          find t_core {rw t_core_eq_p_corner},
        end,
      end,
    use [p_corner_coord, p_corner_coord_in_coords],
    dsimp[p_corner_coord, T_core_point_to_i_coord_fn],
    rw is_periodic at T_is_periodic,
    rw [t_def, add_vectors],
    simp only [vector.nth_of_fn],
    by_cases t_core_eq_zero_at_i : t_core.nth i = 0,
    { use [vector.nth (double_int_vector t_offset) i, 0, 0],
      split, exact rfl.le,
      split, norm_num,
      rw [int_point_to_point, ← t_core_eq_p_corner, t_core_eq_zero_at_i],
      simp only [zero_add, add_zero, int.cast_zero, eq_self_iff_true, vector.nth_of_fn, and_self],
    },
    rename t_core_eq_zero_at_i t_core_ne_zero_at_i,
    use [vector.nth (double_int_vector t_offset) i - 1, -1, t_core.nth i + 1],
    rw in_cube at p_in_t_core,
    replace p_in_t_core := p_in_t_core i,
    rw [p_eq_zero_at_i] at p_in_t_core,
    cases p_in_t_core with t_core_le_zero zero_lt_t_core_add_one,
    have t_core_add_one_lt_one : t_core.nth i + 1 < 1 := 
      by {norm_num, rw lt_iff_le_and_ne, exact ⟨t_core_le_zero, t_core_ne_zero_at_i⟩},
    split, exact le_of_lt zero_lt_t_core_add_one,
    split, exact t_core_add_one_lt_one,
    split,
    { rw int_point_to_point,
      simp only [sub_add_add_cancel, int.cast_one, vector.nth_of_fn, int.cast_sub],
      rw add_comm,
    },
    norm_num,
    rw t_core_eq_p_corner,
  },
  rename p_eq_zero_at_i p_ne_zero_at_i,
  let p_sub_ei : point d := vector.of_fn (λ j, if(i = j) then 0 else p.nth j),
  have p_sub_ei_has_core_points_finset_property :
    ∀ j : fin d, (i = j → p_sub_ei.nth j = 0) ∧ (j.val < d → p_sub_ei.nth j = 0 ∨ p_sub_ei.nth j = 1) ∧ (j.val ≥ d → p_sub_ei.nth j = 0) :=
    begin
      intro j,
      replace p_in_core_points := p_in_core_points j,
      dsimp[p_sub_ei], 
      simp only [ge_iff_le, vector.nth_of_fn, ite_eq_left_iff],
      split, 
      { intro i_eq_j,
        intro i_ne_j,
        exfalso,
        exact i_ne_j i_eq_j,
      },
      split,
      { intro j_lt_d,
        by_cases i_eq_j : i = j,
        { left,
          intro i_ne_j,
          exfalso,
          exact i_ne_j i_eq_j,
        },
        rename i_eq_j i_ne_j,
        rw if_neg i_ne_j,
        cases p_in_core_points with p_eq_zero p_eq_one, {left, intro _, exact p_eq_zero},
        right,
        exact p_eq_one,
      },
      intro j_ge_d,
      exfalso,
      have j_lt_d := j.property,
      clear_except j_ge_d j_lt_d,
      simp only [fin.val_eq_coe] at j_lt_d,
      linarith,
    end,
  have p_sub_ei_in_core_points_finset := core_points_finset_property p_sub_ei p_sub_ei_has_core_points_finset_property,
  let p_sub_ei_corner := (point_to_corner T_is_tiling p_sub_ei).val,
  have p_sub_ei_corner_def : p_sub_ei_corner = (point_to_corner T_is_tiling p_sub_ei).val := by refl,
  have p_sub_ei_corner_property := (point_to_corner T_is_tiling p_sub_ei).property,
  rw ← p_sub_ei_corner_def at p_sub_ei_corner_property,
  rcases p_sub_ei_corner_property with ⟨p_sub_ei_corner_in_T, p_sub_ei_in_p_sub_ei_corner, p_sub_ei_corner_unique⟩,
  have p_sub_ei_corner_eq_t_core_sub_one : p_sub_ei_corner.nth i = t_core.nth i - 1 :=
    begin
      let p_sub_ei_as_int_point : int_point d := vector.of_fn (λ j : fin d, if(p_sub_ei.nth j = 0) then 0 else 1),
      have p_sub_ei_eq_p_sub_ei_as_int_point :
        (let fn : fin d → ℝ := λ (x : fin d), ↑(vector.nth p_sub_ei_as_int_point x) in vector.of_fn fn) = p_sub_ei :=
        begin
          --This proof uses if_pos in a somewhat atypical manner because other attempts have run into "motive is not type
          --correct" issues with the nested ite statements
          apply vector.ext,
          intro j,
          simp only [vector.nth_of_fn],
          by_cases i_eq_j : i = j,
          { rw if_pos, {rw if_pos i_eq_j, norm_num},
            rw if_pos i_eq_j,
          },
          rename i_eq_j i_ne_j,
          by_cases p_eq_zero : p.nth j = 0,
          { rw if_pos, {rw [if_neg i_ne_j, p_eq_zero], norm_num,},
            rw [if_neg i_ne_j, p_eq_zero],
          },
          rename p_eq_zero p_ne_zero,
          rw if_neg,
          { rw if_neg i_ne_j,
            cases p_in_core_points j with p_eq_zero p_eq_one, {exfalso, exact p_ne_zero p_eq_zero,},
            rw p_eq_one,
            norm_num,
          },
          rw if_neg i_ne_j,
          exact p_ne_zero,
        end,
      have p_eq_p_sub_ei_add_ei : p = add_vectors p_sub_ei (unit_basis_vector i) :=
        begin
          apply vector.ext,
          intro j,
          dsimp[p_sub_ei],
          rw [unit_basis_vector, add_vectors],
          simp only [vector.nth_of_fn],
          cases p_in_core_points j with p_eq_zero p_eq_one,
          { rw p_eq_zero,
            simp only [if_t_t, zero_add],
            by_cases i_eq_j : i = j,
            { rw ← i_eq_j at p_eq_zero,
              exfalso,
              exact p_ne_zero_at_i p_eq_zero,
            },
            rename i_eq_j i_ne_j,
            rw if_neg i_ne_j,
          },
          rw p_eq_one,
          by_cases i_eq_j : i = j, rw [if_pos i_eq_j, if_pos i_eq_j, zero_add],
          rename i_eq_j i_ne_j,
          rw [if_neg i_ne_j, if_neg i_ne_j, add_zero],
        end,
      have p_corner_eq_t_core : ↑(point_to_corner T_is_tiling p) = t_core :=
        begin
          have p_corner_property := (point_to_corner T_is_tiling p).property,
          simp only [subtype.val_eq_coe] at p_corner_property,
          rcases p_corner_property with ⟨p_corner_in_T, p_in_p_corner, p_corner_unique⟩,
          symmetry,
          exact p_corner_unique t_core t_core_in_T p_in_t_core,
        end,
      have cube_distance_lemma_fact := cube_distance_lemma d T T_is_tiling p_sub_ei_as_int_point i,
      rw [int_point_to_corner, int_point_to_point] at cube_distance_lemma_fact,
      simp only [subtype.val_eq_coe] at cube_distance_lemma_fact,
      simp only [subtype.val_eq_coe] at p_sub_ei_corner_def,
      rw [p_sub_ei_eq_p_sub_ei_as_int_point, ← p_sub_ei_corner_def, ← p_eq_p_sub_ei_add_ei, p_corner_eq_t_core] at cube_distance_lemma_fact,
      clear_except cube_distance_lemma_fact,
      linarith,
    end,
  have p_sub_ei_corner_has_T_core_map_property : p_sub_ei_corner ∈ T ∧ ∃ p_sub_ei : point d, in_cube p_sub_ei_corner p_sub_ei ∧
    ∀ (j : fin d), (i = j → vector.nth p_sub_ei j = 0) ∧ (↑j < d → vector.nth p_sub_ei j = 0 ∨ vector.nth p_sub_ei j = 1) ∧ 
    (↑j ≥ d → vector.nth p_sub_ei j = 0) :=
    ⟨p_sub_ei_corner_in_T, Exists.intro p_sub_ei ⟨p_sub_ei_in_p_sub_ei_corner, p_sub_ei_has_core_points_finset_property⟩⟩,
  let p_sub_ei_corner_coord := T_core_point_to_i_coord_fn (T_core_map ⟨p_sub_ei, p_sub_ei_has_core_points_finset_property⟩),
  have p_sub_ei_corner_coord_in_coords : p_sub_ei_corner_coord ∈ coords :=
    begin
      dsimp[coords, coords_list, T_core_list, T_core],
      simp only [exists_prop, list.mem_map, finset.mem_map, list.mem_to_finset, ge_iff_le, finset.mem_to_list, subtype.exists,
        list.map],
      use [p_sub_ei_corner, p_sub_ei_corner_has_T_core_map_property],
      split,
      { use [p_sub_ei, p_sub_ei_has_core_points_finset_property],
        split, exact p_sub_ei_in_core_points_finset,
        dsimp[T_core_map],
        apply subtype.ext,
        simp only [subtype.coe_mk],
        symmetry,
        dsimp[p_sub_ei_corner],
        refl,
      },
      dsimp[p_sub_ei_corner_coord, p_sub_ei_corner],
      refl,
    end,
  use [p_sub_ei_corner_coord, p_sub_ei_corner_coord_in_coords],
  dsimp [p_sub_ei_corner_coord, T_core_point_to_i_coord_fn],
  rw is_periodic at T_is_periodic,
  rw [t_def, add_vectors],
  simp only [vector.nth_of_fn],
  by_cases t_core_eq_one_at_i : t_core.nth i = 1,
  { use [vector.nth (double_int_vector t_offset) i + 1, 0, 0],
    split, exact rfl.le,
    split, norm_num,
    rw [int_point_to_point, t_core_eq_one_at_i],
    simp only [true_and, add_zero, if_true, eq_self_iff_true, int.cast_one, vector.nth_of_fn, zero_add, int.cast_neg],
    simp only [subtype.val_eq_coe] at p_sub_ei_corner_def,
    rw [← p_sub_ei_corner_def, p_sub_ei_corner_eq_t_core_sub_one, t_core_eq_one_at_i],
    norm_num,
    rw add_comm,
  },
  rename t_core_eq_one_at_i t_core_ne_one_at_i,
  use [vector.nth (double_int_vector t_offset) i, -1, t_core.nth i],
  rw in_cube at p_in_t_core,
  replace p_in_t_core := p_in_t_core i,
  have p_eq_one_at_i : p.nth i = 1 :=
    begin
      cases p_in_core_points i with p_eq_zero_at_i p_eq_one_at_i,
      { exfalso,
        exact p_ne_zero_at_i p_eq_zero_at_i,
      },
      exact p_eq_one_at_i,
    end,
  rw [p_eq_one_at_i] at p_in_t_core,
  simp only [lt_add_iff_pos_left] at p_in_t_core,
  cases p_in_t_core with t_core_le_one zero_lt_t_core,
  have t_core_lt_one : t_core.nth i < 1 := by {rw lt_iff_le_and_ne, exact ⟨t_core_le_one, t_core_ne_one_at_i⟩},
  split, exact le_of_lt zero_lt_t_core,
  split, exact t_core_lt_one,
  split, {rw int_point_to_point, simp only [vector.nth_of_fn], rw add_comm},
  simp only [subtype.val_eq_coe] at p_sub_ei_corner_def,
  rw [← p_sub_ei_corner_def, p_sub_ei_corner_eq_t_core_sub_one],
  norm_num,
  clear_except,
  linarith,
end