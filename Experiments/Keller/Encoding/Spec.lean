/-
Copyright (c) 2024 The Trestle Contributors.
Released under the Apache License v2.0; see LICENSE for full text.

Authors: James Gallicchio
-/

import Trestle.Model.PropPred
import Trestle.Encode.Cardinality.AMO

import Experiments.Keller.KellerGraph
import Experiments.Keller.SymmBreak.C3Zeros

import Experiments.Keller.SR

namespace Keller.Encoding

open Trestle Encode

inductive Vars (n s : Nat)
-- coordinates of each of the 2^n clique nodes
| x (i : BitVec n) (j : Fin n) (k : Fin s)
deriving IndexType, Hashable, Ord

instance : ToString (Vars n s) where
  toString | Vars.x i j k => s!"x{i.toNat},{j},{k}"

inductive AllVars (n s : Nat)
| x (i : BitVec n) (j : Fin n) (k : Fin s)
| y (i i' : BitVec n) (j : Fin n)
| z (i i' : BitVec n) (j : Fin n)
deriving DecidableEq, Repr

instance [Inhabited (Fin n)] [Inhabited (Fin s)] : Inhabited (AllVars n s) where
  default := .x 0 default default

instance : ToString (AllVars n s) where
  toString
    | .x i j k  => s!"x{i.toNat},{j},{k}"
    | .y i i' j => s!"y{i.toNat},{i'.toNat},{j}"
    | .z i i' j => s!"z{i.toNat},{i'.toNat},{j}"

def allBitVecs (n) : Array (BitVec n) := Array.ofFn (BitVec.ofFin)

@[simp] theorem mem_allBitVecs (x : BitVec n) : x ∈ allBitVecs n := by
  simp [allBitVecs]



namespace Spec

open Vars

def baseSpec : Model.PropPred (Vars n s) :=
  (fun τ =>
    -- type 1 clauses in paper
    (∀ (i : BitVec n) (j : Fin n), ∃! k, τ (x i j k)) ∧
    -- type 2 clauses in paper
    (∀ (i i' : BitVec n) (j : Fin n), i ^^^ i' = BitVec.oneAt j →
        ∃ j', j' ≠ j ∧ ∀ k, ¬ τ (x i j' k) ∨ ¬ τ (x i' j' k)) ∧
    -- type 5/6 clauses in paper
    (∀ (i i' : BitVec n), i ≠ i' → ∃ j, i[j] ≠ i'[j] ∧ ∀ (k : Fin s), τ (x i j k) = τ (x i' j k))
  )

def c0_c1_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ =>
    (∀ j, τ (x 0 j SymmBreak.TwoCubes.c0_colors[j])) ∧
    (∀ j, τ (x 1 j SymmBreak.TwoCubes.c1_colors[j]))

def c3_sorted_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ => ∀ (j : Nat) (range : 2 ≤ j ∧ j + 1 < n+2),
    τ (x 3 ⟨j,by omega⟩ 0) → τ (x 3 ⟨j+1,by omega⟩ 0)

def c3_more_nonzero_spec : Model.PropPred (Vars (n+2) (s+2)) :=
  fun τ =>
    ∀ (j : Nat) (range : 2 ≤ j ∧ j + 1 < n + 2)
      (col : Nat) (cr : 2 ≤ col ∧ col ≤ j),
      ¬ τ (x 3 ⟨j,by omega⟩ 0) ∧ τ (x 3 ⟨j+1,by omega⟩ 0) →
      (∀ (_j : Nat) (range : 2 ≤ _j ∧ _j ≤ j),
        ¬ τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))
      → (∀ (_j : Nat) (range : j < _j ∧ _j < n + 2),
        τ (x (SymmBreak.C3Zeros.X col (by omega)) ⟨_j,by omega⟩ 0))

open Model PropPred in
def c3_min_zero_spec : PropPred (Vars (n+2) (s+2)) :=
  fun τ =>
    ∀ j (j_bounds : 5 ≤ j ∧ j < n+2),
      ¬(τ (.x 3 ⟨j-1,by omega⟩ 0)) → (τ (.x 3 ⟨j,by omega⟩ 0)) →
    ∀ (i : BitVec (n+2)) (i1 : i[1] = true),
      (∀ j (hj : 2 ≤ j ∧ j < n+2), i[j] = true → ¬ τ (.x i ⟨j,by omega⟩ 0)) →
      τ ⊨ Cardinality.atLeast (n+2-j) (zeroLits i)
where
  zeroLits (i : BitVec (n+2)) : List (Literal <| Vars (n+2) (s+2)) :=
    List.ofFn (n := n) fun j => .pos (.x i ⟨2+j, by omega⟩ 0)

def fullSpec : Model.PropPred (Vars n s) :=
  fun τ =>
    baseSpec τ ∧
    (match n,s with
    | _+2, _+2 =>
      c0_c1_spec τ
      ∧ c3_sorted_spec τ
      ∧ c3_more_nonzero_spec τ
    | _,_ => True)

/-! #### cliqueToAssn

This segment proves that the spec is satisfied by a Keller clique
-/

def cliqueToAssn (c : KClique n s) : Model.PropAssignment (Vars n s) :=
  fun | .x i j k => (c.get i)[j] = k

def assnToVertices (τ : Model.PropAssignment (Vars n s)) : Set (KVertex n s) :=
  fun ⟨i,cs⟩ => ∀ j, τ (x i j (cs[j]))

open Model.PropPred in
/-- `baseSpec` is satisfied by the assignment generated by `c` -/
theorem cliqueToAssn_satisfies_baseSpec (c : KClique n s) :
    cliqueToAssn c ⊨ baseSpec := by
  unfold baseSpec cliqueToAssn
  refine ⟨?_,?_,?_⟩
  · -- this should just be simp but for some reason existsUnique_eq' is not applying
    intro i j; simp only [Model.PropFun.satisfies_var, decide_eq_true_eq]; apply existsUnique_eq' (a' := (c.get i)[j])
  · intro i i' j is_xor
    have ⟨_,j2,js_ne,h⟩ := c.get_adj_of_xor_eq j is_xor
    use j2, js_ne
    intro k
    simp_all; omega
  · intro i i' is_ne
    have ⟨j1,is_ne_j1,cs_eq_j1,_⟩ := c.get_adj is_ne
    use j1, is_ne_j1
    simpa using cs_eq_j1

open Model.PropPred in
theorem cliqueToAssn_satisfies_c3_min_spec (c : SymmBreak.C3MinZeroSorted n s) :
    cliqueToAssn c.kclique ⊨ c3_min_zero_spec := by
  simp
  simp only [c3_min_zero_spec, cliqueToAssn, decide_eq_true_eq, decide_eq_false_iff_not]
  intro j j_bounds x3_nz x3_zero i i1_true high_bits_nz
  simp only [satisfies_def, Cardinality.satisfies_cardPred, ge_iff_le]
  have := c.c3_min_zero i i1_true high_bits_nz
  clear i1_true high_bits_nz
  convert this <;> clear this
  · rw [eq_comm, show n+2-j = n-(j-2) by omega]
    apply Nat.le_antisymm
    · apply SymmBreak.C3MinZero.count_le_of_nz_prefix (nzCt_le := by omega)
      intro j' j'_bounds
      apply c.c3_nzPrefix (j-1) (by omega) x3_nz; omega
    · apply SymmBreak.C3MinZero.count_ge_of_z_suffix (nzCt_le := by omega)
      intro j' j'_bounds
      apply c.c3_zeroSuffix j (by omega) x3_zero; omega
  · simp [Cardinality.card, c3_min_zero_spec.zeroLits, SymmBreak.C3MinZero.count]
    rw [List.countP_eq_length_filter,
        ← List.toFinset_card_of_nodup ?nodup,
        List.ofFn_eq_map, List.filter_map,
        List.toFinset_map _ _ ?inj,
        Finset.card_map, List.toFinset_filter, List.toFinset_finRange]
    case nodup =>
      apply List.Nodup.filter
      rw [List.nodup_iff_injective_getElem]
      intro a b; simp [Fin.ext_iff]
    case inj =>
      intro a b; simp [Fin.ext_iff]
    simp [LitVar.satisfies_iff, cliqueToAssn, LitVar.mkPos, LitVar.polarity]
    apply Finset.card_eq_of_equiv
    exact {
      toFun := by rintro ⟨j,j_mem⟩; use ⟨2+j,by omega⟩; simpa using j_mem
      invFun := by rintro ⟨j,j_mem⟩; use ⟨j-2,by omega⟩; simp at j_mem ⊢
                   convert j_mem.2; omega
      left_inv := by intro; simp
      right_inv := by
        rintro ⟨j,j_mem⟩; simp [Subtype.ext_iff] at j_mem ⊢
        simp [Fin.ext_iff]; omega
    }


open Model.PropPred in
/-- `fullSpec` is satisfied by a `C3MinZeroSorted` instance -/
theorem cliqueToAssn_satisfies_fullSpec (c : SymmBreak.C3Zeros n s) :
    cliqueToAssn c.kclique ⊨ fullSpec := by
  unfold fullSpec
  simp
  refine ⟨cliqueToAssn_satisfies_baseSpec _, ?_, ?_, ?_⟩
  · simp [c0_c1_spec, cliqueToAssn]
  · simp [c3_sorted_spec, cliqueToAssn]
    intros; apply c.c3_zeros_sorted
    · assumption
    · omega
  · simp only [
      c3_more_nonzero_spec, add_lt_add_iff_right, cliqueToAssn,
      decide_eq_true_eq]
    rintro j jrange col crange c3_nz_z
    apply c.c3_more_nonzero j (by omega) c3_nz_z col crange

/-- This direction is more complicated, and also we don't need it,
    but we prove it as an interesting aside. -/
theorem clique_of_satisfies_baseSpec {τ : Model.PropAssignment (Vars n s)} :
    open Model.PropPred in τ ⊨ baseSpec → ∃ c : KClique n s, τ = cliqueToAssn c := by
  rintro ⟨coords,twoDiffs,sGaps⟩
  let verts : Finset (KVertex n s) :=
    Finset.univ (α := BitVec n)
    |>.map ⟨fun i => ⟨i,Vector.ofFn fun j => (coords i j).choose⟩
      , by intro; simp⟩
  refine ⟨
    ⟨verts
    ,?isClique,?card⟩
    ,?eqτ⟩
  case card => simp [verts]
  case isClique =>
    rintro ⟨i1,c1⟩ mem1 ⟨i2,c2⟩ mem2 ne
    -- mem1 and mem2 essentially tell us how to interpret τ
    replace mem1 : ∀ j k, τ (Vars.x i1 j k) = true ↔ k = c1[j.val] := by
      intro j k
      have := mem1; simp [verts] at this
      have := congrArg (·[j]) this; simp at this
      have := this ▸ Exists.choose_spec (coords i1 j)
      exact ⟨this.2 k, fun h => h ▸ this.1⟩
    replace mem2 : ∀ j k, τ (Vars.x i2 j k) = true ↔ k = c2[j.val] := by
      intro j k
      have := mem2; simp [verts] at this
      have := congrArg (·[j]) this; simp at this
      have := this ▸ Exists.choose_spec (coords i2 j)
      exact ⟨this.2 k, fun h => h ▸ this.1⟩
    -- now we can show the indices are diff
    replace ne : i1 ≠ i2 := by
      rintro rfl; apply ne; simp; ext1 j hj
      rw [← mem2 ⟨j,hj⟩, mem1]
    -- get the sgap
    specialize sGaps i1 i2 ne
    rcases sGaps with ⟨j1,is_ne_j1,cs_eq_j1⟩
    use j1, is_ne_j1
    constructor
    · -- this is a cool case to step through
      simp; rw [← mem2 j1, ← cs_eq_j1, mem1]
    if just_one_diff : i1 ^^^ i2 = 1#n <<< j1.val then
      specialize twoDiffs i1 i2 j1 just_one_diff
      rcases twoDiffs with ⟨j2,js_ne,k⟩
      use j2, js_ne.symm
      right; intro; simp_all
    else
      rw [BitVec.eq_of_getElem_eq_iff] at just_one_diff
      simp at just_one_diff
      rcases just_one_diff with ⟨j2,hj2,h⟩
      use ⟨j2,hj2⟩
      rw [Bool.eq_iff_iff, not_iff] at h
      simp at h
      have : j1 ≠ ⟨j2,hj2⟩ := by
        rintro rfl; simp [h] at is_ne_j1
      simp [this]; left
      cases j1; simp_all; omega
  case eqτ =>
    ext ⟨i,j,k⟩
    rw [Bool.eq_iff_iff]
    simp only [cliqueToAssn]
    generalize hcs : KClique.get _ _ = cs
    rw [KClique.get_eq_iff_mem] at hcs
    simp [verts] at hcs; subst hcs
    simp
    have := Exists.choose_spec (coords i j)
    simp at this
    generalize Exists.choose _ = boop at this ⊢
    clear * - this
    aesop
